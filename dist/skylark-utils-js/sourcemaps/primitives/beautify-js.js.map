{"version":3,"sources":["primitives/beautify-js.js"],"names":["define","in_array","what","arr","i","length","trim","s","replace","js_beautify","js_source_text","options","beautifier","Beautifier","beautify","create_flags","flags_base","mode","next_indent_level","indentation_level","output","just_added_newline","line_indent_level","next_flags","parent","last_text","last_word","declaration_statement","declaration_assignment","multiline_frame","if_block","else_block","do_block","do_while","in_case_statement","in_case","case_body","start_line_index","get_line_number","ternary_depth","handle_token","local_token","newlines","keep_whitespace","opt","keep_array_indentation","is_array","flags","print_newline","max_preserve_newlines","preserve_newlines","current_token","handlers","type","split_newlines","out","idx","indexOf","push","substring","allow_wrap_or_preserved_newline","force_linewrap","undefined","wanted_newline","wrap_line_length","proposed_line_length","current_line","get_character_count","text","space_before_token","force_newline","preserve_statement_flags","last_type","MODE","Statement","restore_mode","add_new_line","print_token_line_indentation","whitespace_before","set_indent","print_token","printable_token","add_token","indent","deindent","set_mode","flag_store","previous_flags","ArrayLiteral","is_expression","Expression","ForInitializer","Conditional","pop","remove_redundant_indentation","start_of_object_property","ObjectLiteral","start_of_statement","BlockStatement","all_lines_start_with","lines","c","line","charAt","each_line_matches_indent","len","is_special_word","word","get_token","offset","index","token_pos","tokens","handle_start_expr","next_mode","Tokenizer","line_starters","space_in_paren","last_last_text","space_after_anon_function","space_before_conditional","handle_end_expr","space_in_empty_paren","handle_start_block","next_token","second_token","empty_braces","comments_before","empty_anonymous_function","brace_style","handle_end_block","handle_word","jslint_happy","just_added_blankline","prefix","last","handle_semicolon","handle_string","handle_equals","handle_comma","handle_operator","space_before","space_after","handle_block_comment","j","javadoc","starless","lastIndent","lastIndentLength","slice","handle_inline_comment","handle_comment","handle_dot","break_chained_methods","handle_unknown","handle_eof","indent_string","baseIndentString","TK_START_EXPR","TK_END_EXPR","TK_START_BLOCK","TK_END_BLOCK","TK_WORD","TK_RESERVED","TK_SEMICOLON","TK_STRING","TK_EQUALS","TK_OPERATOR","TK_COMMA","TK_BLOCK_COMMENT","TK_INLINE_COMMENT","TK_COMMENT","TK_DOT","TK_UNKNOWN","TK_EOF","braces_on_own_line","indent_size","parseInt","indent_char","unescape_strings","e4x","end_with_newline","indent_with_tabs","preindent_index","Output","this","sweet_code","tokenizer","tokenize","get_code","OutputLine","_character_count","_indent_count","_items","_empty","level","baseIndentLength","indent_length","is_empty","input","remove_indent","toString","result","indent_cache","join","add_space_before_token","frame","output_length","eat_newlines","opts","tokenize_next","resulting_string","whitespace_on_this_line","n_newlines","whitespace_before_token","parser_pos","input_length","last_token","Token","whitespace","digit","test","allow_decimal","allow_e","local_digit","acorn","isIdentifierStart","charCodeAt","isIdentifierChar","reserved_words","comment","inline_comment","match","sep","esc","has_char_escapes","in_char_class","newline","xmlRegExp","xmlStr","exec","rootTag","depth","isEndTag","tagName","isSingletonTag","xmlLength","unescape_string","sharp","in_html_comment","punct","pos","s_hex","escaped","substr","String","fromCharCode","split","concat","next","token_values","open","open_stack","comments","exports","nonASCIIidentifierStartChars","nonASCIIidentifierChars","nonASCIIidentifierStart","RegExp","nonASCIIidentifier","code"],"mappings":"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","file":"../../primitives/beautify-js.js","sourcesContent":["/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2013 Einar Lielmanis and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n JS Beautifier\n---------------\n\n\n  Written by Einar Lielmanis, <einar@jsbeautifier.org>\n      http://jsbeautifier.org/\n\n  Originally converted to javascript by Vital, <vital76@gmail.com>\n  \"End braces on own line\" added by Chris J. Shull, <chrisjshull@gmail.com>\n  Parsing improvements for brace-less statements by Liam Newman <bitwiseman@gmail.com>\n\n\n  Usage:\n    js_beautify(js_source_text);\n    js_beautify(js_source_text, options);\n\n  The options are:\n    indent_size (default 4)          - indentation size,\n    indent_char (default space)      - character to indent with,\n    preserve_newlines (default true) - whether existing line breaks should be preserved,\n    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,\n\n    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.\n\n            jslint_happy        !jslint_happy\n            ---------------------------------\n            function ()         function()\n\n            switch () {         switch() {\n            case 1:               case 1:\n              break;                break;\n            }                   }\n\n    space_after_anon_function (default false) - should the space before an anonymous function's parens be added, \"function()\" vs \"function ()\",\n          NOTE: This option is overriden by jslint_happy (i.e. if jslint_happy is true, space_after_anon_function is true by design)\n\n    brace_style (default \"collapse\") - \"collapse\" | \"expand\" | \"end-expand\" | \"none\"\n            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.\n\n    space_before_conditional (default true) - should the space before conditional statement be added, \"if(true)\" vs \"if (true)\",\n\n    unescape_strings (default false) - should printable characters in strings encoded in \\xNN notation be unescaped, \"example\" vs \"\\x65\\x78\\x61\\x6d\\x70\\x6c\\x65\"\n\n    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.\n          NOTE: This is not a hard limit. Lines will continue until a point where a newline would\n                be preserved if it were present.\n\n    end_with_newline (default false)  - end output with a newline\n\n\n    e.g\n\n    js_beautify(js_source_text, {\n      'indent_size': 1,\n      'indent_char': '\\t'\n    });\n\n*/\n\ndefine([],function() {\n\n    var acorn = {};\n    (function (exports) {\n      // This section of code is taken from acorn.\n      //\n      // Acorn was written by Marijn Haverbeke and released under an MIT\n      // license. The Unicode regexps (for identifiers and whitespace) were\n      // taken from [Esprima](http://esprima.org) by Ariya Hidayat.\n      //\n      // Git repositories for Acorn are available at\n      //\n      //     http://marijnhaverbeke.nl/git/acorn\n      //     https://github.com/marijnh/acorn.git\n\n      // ## Character categories\n\n      // Big ugly regular expressions that match characters in the\n      // whitespace, identifier, and identifier-start categories. These\n      // are only applied when a character is found to actually have a\n      // code point above 128.\n\n      var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n      var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n      var nonASCIIidentifierChars = \"\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n      var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n      var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n      // Whether a single character denotes a newline.\n\n      var newline = exports.newline = /[\\n\\r\\u2028\\u2029]/;\n\n      // Matches a whole line break (where CRLF is considered a single\n      // line break). Used to count lines.\n\n      var lineBreak = /\\r\\n|[\\n\\r\\u2028\\u2029]/g;\n\n      // Test whether a given character code starts an identifier.\n\n      var isIdentifierStart = exports.isIdentifierStart = function(code) {\n        if (code < 65) return code === 36;\n        if (code < 91) return true;\n        if (code < 97) return code === 95;\n        if (code < 123)return true;\n        return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n      };\n\n      // Test whether a given character is part of an identifier.\n\n      var isIdentifierChar = exports.isIdentifierChar = function(code) {\n        if (code < 48) return code === 36;\n        if (code < 58) return true;\n        if (code < 65) return false;\n        if (code < 91) return true;\n        if (code < 97) return code === 95;\n        if (code < 123)return true;\n        return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n      };\n    })(acorn);\n\n    function in_array(what, arr) {\n        for (var i = 0; i < arr.length; i += 1) {\n            if (arr[i] === what) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function trim(s) {\n        return s.replace(/^\\s+|\\s+$/g, '');\n    }\n\n    function js_beautify(js_source_text, options) {\n        \"use strict\";\n        var beautifier = new Beautifier(js_source_text, options);\n        return beautifier.beautify();\n    }\n\n    var MODE = {\n            BlockStatement: 'BlockStatement', // 'BLOCK'\n            Statement: 'Statement', // 'STATEMENT'\n            ObjectLiteral: 'ObjectLiteral', // 'OBJECT',\n            ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',\n            ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',\n            Conditional: 'Conditional', //'(COND-EXPRESSION)',\n            Expression: 'Expression' //'(EXPRESSION)'\n        };\n\n    function Beautifier(js_source_text, options) {\n        \"use strict\";\n        var output\n        var tokens = [], token_pos;\n        var Tokenizer;\n        var current_token;\n        var last_type, last_last_text, indent_string;\n        var flags, previous_flags, flag_store;\n        var prefix;\n\n        var handlers, opt;\n        var baseIndentString = '';\n\n        handlers = {\n            'TK_START_EXPR': handle_start_expr,\n            'TK_END_EXPR': handle_end_expr,\n            'TK_START_BLOCK': handle_start_block,\n            'TK_END_BLOCK': handle_end_block,\n            'TK_WORD': handle_word,\n            'TK_RESERVED': handle_word,\n            'TK_SEMICOLON': handle_semicolon,\n            'TK_STRING': handle_string,\n            'TK_EQUALS': handle_equals,\n            'TK_OPERATOR': handle_operator,\n            'TK_COMMA': handle_comma,\n            'TK_BLOCK_COMMENT': handle_block_comment,\n            'TK_INLINE_COMMENT': handle_inline_comment,\n            'TK_COMMENT': handle_comment,\n            'TK_DOT': handle_dot,\n            'TK_UNKNOWN': handle_unknown,\n            'TK_EOF': handle_eof\n        };\n\n        function create_flags(flags_base, mode) {\n            var next_indent_level = 0;\n            if (flags_base) {\n                next_indent_level = flags_base.indentation_level;\n                if (!output.just_added_newline() &&\n                    flags_base.line_indent_level > next_indent_level) {\n                    next_indent_level = flags_base.line_indent_level;\n                }\n            }\n\n            var next_flags = {\n                mode: mode,\n                parent: flags_base,\n                last_text: flags_base ? flags_base.last_text : '', // last token text\n                last_word: flags_base ? flags_base.last_word : '', // last 'TK_WORD' passed\n                declaration_statement: false,\n                declaration_assignment: false,\n                multiline_frame: false,\n                if_block: false,\n                else_block: false,\n                do_block: false,\n                do_while: false,\n                in_case_statement: false, // switch(..){ INSIDE HERE }\n                in_case: false, // we're on the exact line with \"case 0:\"\n                case_body: false, // the indented case-action block\n                indentation_level: next_indent_level,\n                line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,\n                start_line_index: output.get_line_number(),\n                ternary_depth: 0\n            };\n            return next_flags;\n        }\n\n        // Some interpreters have unexpected results with foo = baz || bar;\n        options = options ? options : {};\n        opt = {};\n\n        // compatibility\n        if (options.braces_on_own_line !== undefined) { //graceful handling of deprecated option\n            opt.brace_style = options.braces_on_own_line ? \"expand\" : \"collapse\";\n        }\n        opt.brace_style = options.brace_style ? options.brace_style : (opt.brace_style ? opt.brace_style : \"collapse\");\n\n        // graceful handling of deprecated option\n        if (opt.brace_style === \"expand-strict\") {\n            opt.brace_style = \"expand\";\n        }\n\n\n        opt.indent_size = options.indent_size ? parseInt(options.indent_size, 10) : 4;\n        opt.indent_char = options.indent_char ? options.indent_char : ' ';\n        opt.preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;\n        opt.break_chained_methods = (options.break_chained_methods === undefined) ? false : options.break_chained_methods;\n        opt.max_preserve_newlines = (options.max_preserve_newlines === undefined) ? 0 : parseInt(options.max_preserve_newlines, 10);\n        opt.space_in_paren = (options.space_in_paren === undefined) ? false : options.space_in_paren;\n        opt.space_in_empty_paren = (options.space_in_empty_paren === undefined) ? false : options.space_in_empty_paren;\n        opt.jslint_happy = (options.jslint_happy === undefined) ? false : options.jslint_happy;\n        opt.space_after_anon_function = (options.space_after_anon_function === undefined) ? false : options.space_after_anon_function;\n        opt.keep_array_indentation = (options.keep_array_indentation === undefined) ? false : options.keep_array_indentation;\n        opt.space_before_conditional = (options.space_before_conditional === undefined) ? true : options.space_before_conditional;\n        opt.unescape_strings = (options.unescape_strings === undefined) ? false : options.unescape_strings;\n        opt.wrap_line_length = (options.wrap_line_length === undefined) ? 0 : parseInt(options.wrap_line_length, 10);\n        opt.e4x = (options.e4x === undefined) ? false : options.e4x;\n        opt.end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;\n\n\n        // force opt.space_after_anon_function to true if opt.jslint_happy\n        if(opt.jslint_happy) {\n            opt.space_after_anon_function = true;\n        }\n\n        if(options.indent_with_tabs){\n            opt.indent_char = '\\t';\n            opt.indent_size = 1;\n        }\n\n        //----------------------------------\n        indent_string = '';\n        while (opt.indent_size > 0) {\n            indent_string += opt.indent_char;\n            opt.indent_size -= 1;\n        }\n\n        var preindent_index = 0;\n        if(js_source_text && js_source_text.length) {\n            while ( (js_source_text.charAt(preindent_index) === ' ' ||\n                    js_source_text.charAt(preindent_index) === '\\t')) {\n                baseIndentString += js_source_text.charAt(preindent_index);\n                preindent_index += 1;\n            }\n            js_source_text = js_source_text.substring(preindent_index);\n        }\n\n        last_type = 'TK_START_BLOCK'; // last token type\n        last_last_text = ''; // pre-last token text\n        output = new Output(indent_string, baseIndentString);\n\n\n        // Stack of parsing/formatting states, including MODE.\n        // We tokenize, parse, and output in an almost purely a forward-only stream of token input\n        // and formatted output.  This makes the beautifier less accurate than full parsers\n        // but also far more tolerant of syntax errors.\n        //\n        // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type\n        // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later\n        // encounter a \":\", we'll switch to to MODE.ObjectLiteral.  If we then see a \";\",\n        // most full parsers would die, but the beautifier gracefully falls back to\n        // MODE.BlockStatement and continues on.\n        flag_store = [];\n        set_mode(MODE.BlockStatement);\n\n        this.beautify = function() {\n\n            /*jshint onevar:true */\n            var local_token, sweet_code;\n            Tokenizer = new tokenizer(js_source_text, opt, indent_string);\n            tokens = Tokenizer.tokenize();\n            token_pos = 0;\n\n            while (local_token = get_token()) {\n                for(var i = 0; i < local_token.comments_before.length; i++) {\n                    // The cleanest handling of inline comments is to treat them as though they aren't there.\n                    // Just continue formatting and the behavior should be logical.\n                    // Also ignore unknown tokens.  Again, this should result in better behavior.\n                    handle_token(local_token.comments_before[i]);\n                }\n                handle_token(local_token);\n\n                last_last_text = flags.last_text;\n                last_type = local_token.type;\n                flags.last_text = local_token.text;\n\n                token_pos += 1;\n            }\n\n            sweet_code = output.get_code();\n            if (opt.end_with_newline) {\n                sweet_code += '\\n';\n            }\n\n            return sweet_code;\n        };\n\n        function handle_token(local_token) {\n            var newlines = local_token.newlines;\n            var keep_whitespace = opt.keep_array_indentation && is_array(flags.mode);\n\n            if (keep_whitespace) {\n                for (i = 0; i < newlines; i += 1) {\n                    print_newline(i > 0);\n                }\n            } else {\n                if (opt.max_preserve_newlines && newlines > opt.max_preserve_newlines) {\n                    newlines = opt.max_preserve_newlines;\n                }\n\n                if (opt.preserve_newlines) {\n                    if (local_token.newlines > 1) {\n                        print_newline();\n                        for (var i = 1; i < newlines; i += 1) {\n                            print_newline(true);\n                        }\n                    }\n                }\n            }\n\n            current_token = local_token;\n            handlers[current_token.type]();\n        }\n\n        // we could use just string.split, but\n        // IE doesn't like returning empty strings\n\n        function split_newlines(s) {\n            //return s.split(/\\x0d\\x0a|\\x0a/);\n\n            s = s.replace(/\\x0d/g, '');\n            var out = [],\n                idx = s.indexOf(\"\\n\");\n            while (idx !== -1) {\n                out.push(s.substring(0, idx));\n                s = s.substring(idx + 1);\n                idx = s.indexOf(\"\\n\");\n            }\n            if (s.length) {\n                out.push(s);\n            }\n            return out;\n        }\n\n        function allow_wrap_or_preserved_newline(force_linewrap) {\n            force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;\n\n            // Never wrap the first token on a line\n            if (output.just_added_newline()) {\n                return\n            }\n\n            if ((opt.preserve_newlines && current_token.wanted_newline) || force_linewrap) {\n                print_newline(false, true);\n            } else if (opt.wrap_line_length) {\n                var proposed_line_length = output.current_line.get_character_count() + current_token.text.length +\n                    (output.space_before_token ? 1 : 0);\n                if (proposed_line_length >= opt.wrap_line_length) {\n                    print_newline(false, true);\n                }\n            }\n        }\n\n        function print_newline(force_newline, preserve_statement_flags) {\n            if (!preserve_statement_flags) {\n                if (flags.last_text !== ';' && flags.last_text !== ',' && flags.last_text !== '=' && last_type !== 'TK_OPERATOR') {\n                    while (flags.mode === MODE.Statement && !flags.if_block && !flags.do_block) {\n                        restore_mode();\n                    }\n                }\n            }\n\n            if (output.add_new_line(force_newline)) {\n                flags.multiline_frame = true;\n            }\n        }\n\n        function print_token_line_indentation() {\n            if (output.just_added_newline()) {\n                if (opt.keep_array_indentation && is_array(flags.mode) && current_token.wanted_newline) {\n                    output.current_line.push(current_token.whitespace_before);\n                    output.space_before_token = false;\n                } else if (output.set_indent(flags.indentation_level)) {\n                    flags.line_indent_level = flags.indentation_level;\n                }\n            }\n        }\n\n        function print_token(printable_token) {\n            printable_token = printable_token || current_token.text;\n            print_token_line_indentation();\n            output.add_token(printable_token);\n        }\n\n        function indent() {\n            flags.indentation_level += 1;\n        }\n\n        function deindent() {\n            if (flags.indentation_level > 0 &&\n                ((!flags.parent) || flags.indentation_level > flags.parent.indentation_level))\n                flags.indentation_level -= 1;\n        }\n\n        function set_mode(mode) {\n            if (flags) {\n                flag_store.push(flags);\n                previous_flags = flags;\n            } else {\n                previous_flags = create_flags(null, mode);\n            }\n\n            flags = create_flags(previous_flags, mode);\n        }\n\n        function is_array(mode) {\n            return mode === MODE.ArrayLiteral;\n        }\n\n        function is_expression(mode) {\n            return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);\n        }\n\n        function restore_mode() {\n            if (flag_store.length > 0) {\n                previous_flags = flags;\n                flags = flag_store.pop();\n                if (previous_flags.mode === MODE.Statement) {\n                    output.remove_redundant_indentation(previous_flags);\n                }\n            }\n        }\n\n        function start_of_object_property() {\n            return flags.parent.mode === MODE.ObjectLiteral && flags.mode === MODE.Statement && (\n                (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set'])));\n        }\n\n        function start_of_statement() {\n            if (\n                    (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && current_token.type === 'TK_WORD') ||\n                    (last_type === 'TK_RESERVED' && flags.last_text === 'do') ||\n                    (last_type === 'TK_RESERVED' && flags.last_text === 'return' && !current_token.wanted_newline) ||\n                    (last_type === 'TK_RESERVED' && flags.last_text === 'else' && !(current_token.type === 'TK_RESERVED' && current_token.text === 'if')) ||\n                    (last_type === 'TK_END_EXPR' && (previous_flags.mode === MODE.ForInitializer || previous_flags.mode === MODE.Conditional)) ||\n                    (last_type === 'TK_WORD' && flags.mode === MODE.BlockStatement\n                        && !flags.in_case\n                        && !(current_token.text === '--' || current_token.text === '++')\n                        && current_token.type !== 'TK_WORD' && current_token.type !== 'TK_RESERVED') ||\n                    (flags.mode === MODE.ObjectLiteral && (\n                        (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set']))))\n                ) {\n\n                set_mode(MODE.Statement);\n                indent();\n\n                if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && current_token.type === 'TK_WORD') {\n                    flags.declaration_statement = true;\n                }\n\n                // Issue #276:\n                // If starting a new statement with [if, for, while, do], push to a new line.\n                // if (a) if (b) if(c) d(); else e(); else f();\n                if (!start_of_object_property()) {\n                    allow_wrap_or_preserved_newline(\n                        current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['do', 'for', 'if', 'while']));\n                }\n\n                return true;\n            }\n            return false;\n        }\n\n        function all_lines_start_with(lines, c) {\n            for (var i = 0; i < lines.length; i++) {\n                var line = trim(lines[i]);\n                if (line.charAt(0) !== c) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        function each_line_matches_indent(lines, indent) {\n            var i = 0,\n                len = lines.length,\n                line;\n            for (; i < len; i++) {\n                line = lines[i];\n                // allow empty lines to pass through\n                if (line && line.indexOf(indent) !== 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        function is_special_word(word) {\n            return in_array(word, ['case', 'return', 'do', 'if', 'throw', 'else']);\n        }\n\n        function get_token(offset) {\n            var index = token_pos + (offset || 0);\n            return (index < 0 || index >= tokens.length) ? null : tokens[index];\n        }\n\n        function handle_start_expr() {\n            if (start_of_statement()) {\n                // The conditional starts the statement if appropriate.\n            }\n\n            var next_mode = MODE.Expression;\n            if (current_token.text === '[') {\n\n                if (last_type === 'TK_WORD' || flags.last_text === ')') {\n                    // this is array index specifier, break immediately\n                    // a[x], fn()[x]\n                    if (last_type === 'TK_RESERVED' && in_array(flags.last_text, Tokenizer.line_starters)) {\n                        output.space_before_token = true;\n                    }\n                    set_mode(next_mode);\n                    print_token();\n                    indent();\n                    if (opt.space_in_paren) {\n                        output.space_before_token = true;\n                    }\n                    return;\n                }\n\n                next_mode = MODE.ArrayLiteral;\n                if (is_array(flags.mode)) {\n                    if (flags.last_text === '[' ||\n                        (flags.last_text === ',' && (last_last_text === ']' || last_last_text === '}'))) {\n                        // ], [ goes to new line\n                        // }, [ goes to new line\n                        if (!opt.keep_array_indentation) {\n                            print_newline();\n                        }\n                    }\n                }\n\n            } else {\n                if (last_type === 'TK_RESERVED' && flags.last_text === 'for') {\n                    next_mode = MODE.ForInitializer;\n                } else if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['if', 'while'])) {\n                    next_mode = MODE.Conditional;\n                } else {\n                    // next_mode = MODE.Expression;\n                }\n            }\n\n            if (flags.last_text === ';' || last_type === 'TK_START_BLOCK') {\n                print_newline();\n            } else if (last_type === 'TK_END_EXPR' || last_type === 'TK_START_EXPR' || last_type === 'TK_END_BLOCK' || flags.last_text === '.') {\n                // TODO: Consider whether forcing this is required.  Review failing tests when removed.\n                allow_wrap_or_preserved_newline(current_token.wanted_newline);\n                // do nothing on (( and )( and ][ and ]( and .(\n            } else if (!(last_type === 'TK_RESERVED' && current_token.text === '(') && last_type !== 'TK_WORD' && last_type !== 'TK_OPERATOR') {\n                output.space_before_token = true;\n            } else if ((last_type === 'TK_RESERVED' && (flags.last_word === 'function' || flags.last_word === 'typeof')) ||\n                (flags.last_text === '*' && last_last_text === 'function')) {\n                // function() vs function ()\n                if (opt.space_after_anon_function) {\n                    output.space_before_token = true;\n                }\n            } else if (last_type === 'TK_RESERVED' && (in_array(flags.last_text, Tokenizer.line_starters) || flags.last_text === 'catch')) {\n                if (opt.space_before_conditional) {\n                    output.space_before_token = true;\n                }\n            }\n\n            // Support of this kind of newline preservation.\n            // a = (b &&\n            //     (c || d));\n            if (current_token.text === '(') {\n                if (last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {\n                    if (!start_of_object_property()) {\n                        allow_wrap_or_preserved_newline();\n                    }\n                }\n            }\n\n            set_mode(next_mode);\n            print_token();\n            if (opt.space_in_paren) {\n                output.space_before_token = true;\n            }\n\n            // In all cases, if we newline while inside an expression it should be indented.\n            indent();\n        }\n\n        function handle_end_expr() {\n            // statements inside expressions are not valid syntax, but...\n            // statements must all be closed when their container closes\n            while (flags.mode === MODE.Statement) {\n                restore_mode();\n            }\n\n            if (flags.multiline_frame) {\n                allow_wrap_or_preserved_newline(current_token.text === ']' && is_array(flags.mode) && !opt.keep_array_indentation);\n            }\n\n            if (opt.space_in_paren) {\n                if (last_type === 'TK_START_EXPR' && ! opt.space_in_empty_paren) {\n                    // () [] no inner space in empty parens like these, ever, ref #320\n                    output.trim();\n                    output.space_before_token = false;\n                } else {\n                    output.space_before_token = true;\n                }\n            }\n            if (current_token.text === ']' && opt.keep_array_indentation) {\n                print_token();\n                restore_mode();\n            } else {\n                restore_mode();\n                print_token();\n            }\n            output.remove_redundant_indentation(previous_flags);\n\n            // do {} while () // no statement required after\n            if (flags.do_while && previous_flags.mode === MODE.Conditional) {\n                previous_flags.mode = MODE.Expression;\n                flags.do_block = false;\n                flags.do_while = false;\n\n            }\n        }\n\n        function handle_start_block() {\n            // Check if this is should be treated as a ObjectLiteral\n            var next_token = get_token(1)\n            var second_token = get_token(2)\n            if (second_token && (\n                    (second_token.text === ':' && in_array(next_token.type, ['TK_STRING', 'TK_WORD', 'TK_RESERVED']))\n                    || (in_array(next_token.text, ['get', 'set']) && in_array(second_token.type, ['TK_WORD', 'TK_RESERVED']))\n                )) {\n                // We don't support TypeScript,but we didn't break it for a very long time.\n                // We'll try to keep not breaking it.\n                if (!in_array(last_last_text, ['class','interface'])) {\n                    set_mode(MODE.ObjectLiteral);\n                } else {\n                    set_mode(MODE.BlockStatement);\n                }\n            } else {\n                set_mode(MODE.BlockStatement);\n            }\n\n            var empty_braces = !next_token.comments_before.length &&  next_token.text === '}';\n            var empty_anonymous_function = empty_braces && flags.last_word === 'function' &&\n                last_type === 'TK_END_EXPR';\n\n            if (opt.brace_style === \"expand\" ||\n                (opt.brace_style === \"none\" && current_token.wanted_newline)) {\n                if (last_type !== 'TK_OPERATOR' &&\n                    (empty_anonymous_function ||\n                        last_type === 'TK_EQUALS' ||\n                        (last_type === 'TK_RESERVED' && is_special_word(flags.last_text) && flags.last_text !== 'else'))) {\n                    output.space_before_token = true;\n                } else {\n                    print_newline(false, true);\n                }\n            } else { // collapse\n                if (last_type !== 'TK_OPERATOR' && last_type !== 'TK_START_EXPR') {\n                    if (last_type === 'TK_START_BLOCK') {\n                        print_newline();\n                    } else {\n                        output.space_before_token = true;\n                    }\n                } else {\n                    // if TK_OPERATOR or TK_START_EXPR\n                    if (is_array(previous_flags.mode) && flags.last_text === ',') {\n                        if (last_last_text === '}') {\n                            // }, { in array context\n                            output.space_before_token = true;\n                        } else {\n                            print_newline(); // [a, b, c, {\n                        }\n                    }\n                }\n            }\n            print_token();\n            indent();\n        }\n\n        function handle_end_block() {\n            // statements must all be closed when their container closes\n            while (flags.mode === MODE.Statement) {\n                restore_mode();\n            }\n            var empty_braces = last_type === 'TK_START_BLOCK';\n\n            if (opt.brace_style === \"expand\") {\n                if (!empty_braces) {\n                    print_newline();\n                }\n            } else {\n                // skip {}\n                if (!empty_braces) {\n                    if (is_array(flags.mode) && opt.keep_array_indentation) {\n                        // we REALLY need a newline here, but newliner would skip that\n                        opt.keep_array_indentation = false;\n                        print_newline();\n                        opt.keep_array_indentation = true;\n\n                    } else {\n                        print_newline();\n                    }\n                }\n            }\n            restore_mode();\n            print_token();\n        }\n\n        function handle_word() {\n            if (current_token.type === 'TK_RESERVED' && flags.mode !== MODE.ObjectLiteral &&\n                in_array(current_token.text, ['set', 'get'])) {\n                current_token.type = 'TK_WORD';\n            }\n\n            if (current_token.type === 'TK_RESERVED' && flags.mode === MODE.ObjectLiteral) {\n                var next_token = get_token(1);\n                if (next_token.text == ':') {\n                    current_token.type = 'TK_WORD';\n                }\n            }\n\n            if (start_of_statement()) {\n                // The conditional starts the statement if appropriate.\n            } else if (current_token.wanted_newline && !is_expression(flags.mode) &&\n                (last_type !== 'TK_OPERATOR' || (flags.last_text === '--' || flags.last_text === '++')) &&\n                last_type !== 'TK_EQUALS' &&\n                (opt.preserve_newlines || !(last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const', 'set', 'get'])))) {\n\n                print_newline();\n            }\n\n            if (flags.do_block && !flags.do_while) {\n                if (current_token.type === 'TK_RESERVED' && current_token.text === 'while') {\n                    // do {} ## while ()\n                    output.space_before_token = true;\n                    print_token();\n                    output.space_before_token = true;\n                    flags.do_while = true;\n                    return;\n                } else {\n                    // do {} should always have while as the next word.\n                    // if we don't see the expected while, recover\n                    print_newline();\n                    flags.do_block = false;\n                }\n            }\n\n            // if may be followed by else, or not\n            // Bare/inline ifs are tricky\n            // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();\n            if (flags.if_block) {\n                if (!flags.else_block && (current_token.type === 'TK_RESERVED' && current_token.text === 'else')) {\n                    flags.else_block = true;\n                } else {\n                    while (flags.mode === MODE.Statement) {\n                        restore_mode();\n                    }\n                    flags.if_block = false;\n                    flags.else_block = false;\n                }\n            }\n\n            if (current_token.type === 'TK_RESERVED' && (current_token.text === 'case' || (current_token.text === 'default' && flags.in_case_statement))) {\n                print_newline();\n                if (flags.case_body || opt.jslint_happy) {\n                    // switch cases following one another\n                    deindent();\n                    flags.case_body = false;\n                }\n                print_token();\n                flags.in_case = true;\n                flags.in_case_statement = true;\n                return;\n            }\n\n            if (current_token.type === 'TK_RESERVED' && current_token.text === 'function') {\n                if (in_array(flags.last_text, ['}', ';']) || (output.just_added_newline() && ! in_array(flags.last_text, ['[', '{', ':', '=', ',']))) {\n                    // make sure there is a nice clean space of at least one blank line\n                    // before a new function definition\n                    if ( !output.just_added_blankline() && !current_token.comments_before.length) {\n                        print_newline();\n                        print_newline(true);\n                    }\n                }\n                if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {\n                    if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set', 'new', 'return', 'export'])) {\n                        output.space_before_token = true;\n                    } else if (last_type === 'TK_RESERVED' && flags.last_text === 'default' && last_last_text === 'export') {\n                        output.space_before_token = true;\n                    } else {\n                        print_newline();\n                    }\n                } else if (last_type === 'TK_OPERATOR' || flags.last_text === '=') {\n                    // foo = function\n                    output.space_before_token = true;\n                } else if (!flags.multiline_frame && (is_expression(flags.mode) || is_array(flags.mode))) {\n                    // (function\n                } else {\n                    print_newline();\n                }\n            }\n\n            if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {\n                if (!start_of_object_property()) {\n                    allow_wrap_or_preserved_newline();\n                }\n            }\n\n            if (current_token.type === 'TK_RESERVED' &&  in_array(current_token.text, ['function', 'get', 'set'])) {\n                print_token();\n                flags.last_word = current_token.text;\n                return;\n            }\n\n            prefix = 'NONE';\n\n            if (last_type === 'TK_END_BLOCK') {\n                if (!(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally']))) {\n                    prefix = 'NEWLINE';\n                } else {\n                    if (opt.brace_style === \"expand\" ||\n                        opt.brace_style === \"end-expand\" ||\n                        (opt.brace_style === \"none\" && current_token.wanted_newline)) {\n                        prefix = 'NEWLINE';\n                    } else {\n                        prefix = 'SPACE';\n                        output.space_before_token = true;\n                    }\n                }\n            } else if (last_type === 'TK_SEMICOLON' && flags.mode === MODE.BlockStatement) {\n                // TODO: Should this be for STATEMENT as well?\n                prefix = 'NEWLINE';\n            } else if (last_type === 'TK_SEMICOLON' && is_expression(flags.mode)) {\n                prefix = 'SPACE';\n            } else if (last_type === 'TK_STRING') {\n                prefix = 'NEWLINE';\n            } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD' ||\n                (flags.last_text === '*' && last_last_text === 'function')) {\n                prefix = 'SPACE';\n            } else if (last_type === 'TK_START_BLOCK') {\n                prefix = 'NEWLINE';\n            } else if (last_type === 'TK_END_EXPR') {\n                output.space_before_token = true;\n                prefix = 'NEWLINE';\n            }\n\n            if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, Tokenizer.line_starters) && flags.last_text !== ')') {\n                if (flags.last_text === 'else' || flags.last_text === 'export') {\n                    prefix = 'SPACE';\n                } else {\n                    prefix = 'NEWLINE';\n                }\n\n            }\n\n            if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally'])) {\n                if (last_type !== 'TK_END_BLOCK' ||\n                    opt.brace_style === \"expand\" ||\n                    opt.brace_style === \"end-expand\" ||\n                    (opt.brace_style === \"none\" && current_token.wanted_newline)) {\n                    print_newline();\n                } else {\n                    output.trim(true);\n                    var line = output.current_line;\n                    // If we trimmed and there's something other than a close block before us\n                    // put a newline back in.  Handles '} // comment' scenario.\n                    if (line.last() !== '}') {\n                        print_newline();\n                    }\n                    output.space_before_token = true;\n                }\n            } else if (prefix === 'NEWLINE') {\n                if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {\n                    // no newline between 'return nnn'\n                    output.space_before_token = true;\n                } else if (last_type !== 'TK_END_EXPR') {\n                    if ((last_type !== 'TK_START_EXPR' || !(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['var', 'let', 'const']))) && flags.last_text !== ':') {\n                        // no need to force newline on 'var': for (var x = 0...)\n                        if (current_token.type === 'TK_RESERVED' && current_token.text === 'if' && flags.last_text === 'else') {\n                            // no newline for } else if {\n                            output.space_before_token = true;\n                        } else {\n                            print_newline();\n                        }\n                    }\n                } else if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, Tokenizer.line_starters) && flags.last_text !== ')') {\n                    print_newline();\n                }\n            } else if (flags.multiline_frame && is_array(flags.mode) && flags.last_text === ',' && last_last_text === '}') {\n                print_newline(); // }, in lists get a newline treatment\n            } else if (prefix === 'SPACE') {\n                output.space_before_token = true;\n            }\n            print_token();\n            flags.last_word = current_token.text;\n\n            if (current_token.type === 'TK_RESERVED' && current_token.text === 'do') {\n                flags.do_block = true;\n            }\n\n            if (current_token.type === 'TK_RESERVED' && current_token.text === 'if') {\n                flags.if_block = true;\n            }\n        }\n\n        function handle_semicolon() {\n            if (start_of_statement()) {\n                // The conditional starts the statement if appropriate.\n                // Semicolon can be the start (and end) of a statement\n                output.space_before_token = false;\n            }\n            while (flags.mode === MODE.Statement && !flags.if_block && !flags.do_block) {\n                restore_mode();\n            }\n            print_token();\n        }\n\n        function handle_string() {\n            if (start_of_statement()) {\n                // The conditional starts the statement if appropriate.\n                // One difference - strings want at least a space before\n                output.space_before_token = true;\n            } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {\n                output.space_before_token = true;\n            } else if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {\n                if (!start_of_object_property()) {\n                    allow_wrap_or_preserved_newline();\n                }\n            } else {\n                print_newline();\n            }\n            print_token();\n        }\n\n        function handle_equals() {\n            if (start_of_statement()) {\n                // The conditional starts the statement if appropriate.\n            }\n\n            if (flags.declaration_statement) {\n                // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done\n                flags.declaration_assignment = true;\n            }\n            output.space_before_token = true;\n            print_token();\n            output.space_before_token = true;\n        }\n\n        function handle_comma() {\n            if (flags.declaration_statement) {\n                if (is_expression(flags.parent.mode)) {\n                    // do not break on comma, for(var a = 1, b = 2)\n                    flags.declaration_assignment = false;\n                }\n\n                print_token();\n\n                if (flags.declaration_assignment) {\n                    flags.declaration_assignment = false;\n                    print_newline(false, true);\n                } else {\n                    output.space_before_token = true;\n                }\n                return;\n            }\n\n            print_token();\n            if (flags.mode === MODE.ObjectLiteral ||\n                (flags.mode === MODE.Statement && flags.parent.mode === MODE.ObjectLiteral)) {\n                if (flags.mode === MODE.Statement) {\n                    restore_mode();\n                }\n                print_newline();\n            } else {\n                // EXPR or DO_BLOCK\n                output.space_before_token = true;\n            }\n\n        }\n\n        function handle_operator() {\n            if (start_of_statement()) {\n                // The conditional starts the statement if appropriate.\n            }\n\n            if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {\n                // \"return\" had a special handling in TK_WORD. Now we need to return the favor\n                output.space_before_token = true;\n                print_token();\n                return;\n            }\n\n            // hack for actionscript's import .*;\n            if (current_token.text === '*' && last_type === 'TK_DOT') {\n                print_token();\n                return;\n            }\n\n            if (current_token.text === ':' && flags.in_case) {\n                flags.case_body = true;\n                indent();\n                print_token();\n                print_newline();\n                flags.in_case = false;\n                return;\n            }\n\n            if (current_token.text === '::') {\n                // no spaces around exotic namespacing syntax operator\n                print_token();\n                return;\n            }\n\n            // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1\n            // if there is a newline between -- or ++ and anything else we should preserve it.\n            if (current_token.wanted_newline && (current_token.text === '--' || current_token.text === '++')) {\n                print_newline(false, true);\n            }\n\n            // Allow line wrapping between operators\n            if (last_type === 'TK_OPERATOR') {\n                allow_wrap_or_preserved_newline();\n            }\n\n            var space_before = true;\n            var space_after = true;\n\n            if (in_array(current_token.text, ['--', '++', '!', '~']) || (in_array(current_token.text, ['-', '+']) && (in_array(last_type, ['TK_START_BLOCK', 'TK_START_EXPR', 'TK_EQUALS', 'TK_OPERATOR']) || in_array(flags.last_text, Tokenizer.line_starters) || flags.last_text === ','))) {\n                // unary operators (and binary +/- pretending to be unary) special cases\n\n                space_before = false;\n                space_after = false;\n\n                if (flags.last_text === ';' && is_expression(flags.mode)) {\n                    // for (;; ++i)\n                    //        ^^^\n                    space_before = true;\n                }\n\n                if (last_type === 'TK_RESERVED' || last_type === 'TK_END_EXPR') {\n                    space_before = true;\n                } else if (last_type === 'TK_OPERATOR') {\n                    space_before =\n                        (in_array(current_token.text, ['--', '-']) && in_array(flags.last_text, ['--', '-'])) ||\n                        (in_array(current_token.text, ['++', '+']) && in_array(flags.last_text, ['++', '+']));\n                }\n\n                if ((flags.mode === MODE.BlockStatement || flags.mode === MODE.Statement) && (flags.last_text === '{' || flags.last_text === ';')) {\n                    // { foo; --i }\n                    // foo(); --bar;\n                    print_newline();\n                }\n            } else if (current_token.text === ':') {\n                if (flags.ternary_depth === 0) {\n                    // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.\n                    space_before = false;\n                } else {\n                    flags.ternary_depth -= 1;\n                }\n            } else if (current_token.text === '?') {\n                flags.ternary_depth += 1;\n            } else if (current_token.text === '*' && last_type === 'TK_RESERVED' && flags.last_text === 'function') {\n                space_before = false;\n                space_after = false;\n            }\n            output.space_before_token = output.space_before_token || space_before;\n            print_token();\n            output.space_before_token = space_after;\n        }\n\n        function handle_block_comment() {\n            var lines = split_newlines(current_token.text);\n            var j; // iterator for this case\n            var javadoc = false;\n            var starless = false;\n            var lastIndent = current_token.whitespace_before;\n            var lastIndentLength = lastIndent.length;\n\n            // block comment starts with a new line\n            print_newline(false, true);\n            if (lines.length > 1) {\n                if (all_lines_start_with(lines.slice(1), '*')) {\n                    javadoc = true;\n                }\n                else if (each_line_matches_indent(lines.slice(1), lastIndent)) {\n                    starless = true;\n                }\n            }\n\n            // first line always indented\n            print_token(lines[0]);\n            for (j = 1; j < lines.length; j++) {\n                print_newline(false, true);\n                if (javadoc) {\n                    // javadoc: reformat and re-indent\n                    print_token(' ' + trim(lines[j]));\n                } else if (starless && lines[j].length > lastIndentLength) {\n                    // starless: re-indent non-empty content, avoiding trim\n                    print_token(lines[j].substring(lastIndentLength));\n                } else {\n                    // normal comments output raw\n                    output.add_token(lines[j]);\n                }\n            }\n\n            // for comments of more than one line, make sure there's a new line after\n            print_newline(false, true);\n        }\n\n        function handle_inline_comment() {\n            output.space_before_token = true;\n            print_token();\n            output.space_before_token = true;\n        }\n\n        function handle_comment() {\n            if (current_token.wanted_newline) {\n                print_newline(false, true);\n            } else {\n                output.trim(true);\n            }\n\n            output.space_before_token = true;\n            print_token();\n            print_newline(false, true);\n        }\n\n        function handle_dot() {\n            if (start_of_statement()) {\n                // The conditional starts the statement if appropriate.\n            }\n\n            if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {\n                output.space_before_token = true;\n            } else {\n                // allow preserved newlines before dots in general\n                // force newlines on dots after close paren when break_chained - for bar().baz()\n                allow_wrap_or_preserved_newline(flags.last_text === ')' && opt.break_chained_methods);\n            }\n\n            print_token();\n        }\n\n        function handle_unknown() {\n            print_token();\n\n            if (current_token.text[current_token.text.length - 1] === '\\n') {\n                print_newline();\n            }\n        }\n\n        function handle_eof() {\n            // Unwind any open statements\n            while (flags.mode === MODE.Statement) {\n                restore_mode();\n            }\n        }\n    }\n\n\n    function OutputLine(parent) {\n        var _character_count = 0;\n        // use indent_count as a marker for lines that have preserved indentation\n        var _indent_count = -1;\n\n        var _items = [];\n        var _empty = true;\n\n        this.set_indent = function(level) {\n            _character_count = parent.baseIndentLength + level * parent.indent_length\n            _indent_count = level;\n        }\n\n        this.get_character_count = function() {\n            return _character_count;\n        }\n\n        this.is_empty = function() {\n            return _empty;\n        }\n\n        this.last = function() {\n            if (!this._empty) {\n              return _items[_items.length - 1];\n            } else {\n              return null;\n            }\n        }\n\n        this.push = function(input) {\n            _items.push(input);\n            _character_count += input.length;\n            _empty = false;\n        }\n\n        this.remove_indent = function() {\n            if (_indent_count > 0) {\n                _indent_count -= 1;\n                _character_count -= parent.indent_length\n            }\n        }\n\n        this.trim = function() {\n            while (this.last() === ' ') {\n                var item = _items.pop();\n                _character_count -= 1;\n            }\n            _empty = _items.length === 0;\n        }\n\n        this.toString = function() {\n            var result = '';\n            if (!this._empty) {\n                if (_indent_count >= 0) {\n                    result = parent.indent_cache[_indent_count];\n                }\n                result += _items.join('')\n            }\n            return result;\n        }\n    }\n\n    function Output(indent_string, baseIndentString) {\n        baseIndentString = baseIndentString || '';\n        this.indent_cache = [ baseIndentString ];\n        this.baseIndentLength = baseIndentString.length;\n        this.indent_length = indent_string.length;\n\n        var lines =[];\n        this.baseIndentString = baseIndentString;\n        this.indent_string = indent_string;\n        this.current_line = null;\n        this.space_before_token = false;\n\n        this.get_line_number = function() {\n            return lines.length;\n        }\n\n        // Using object instead of string to allow for later expansion of info about each line\n        this.add_new_line = function(force_newline) {\n            if (this.get_line_number() === 1 && this.just_added_newline()) {\n                return false; // no newline on start of file\n            }\n\n            if (force_newline || !this.just_added_newline()) {\n                this.current_line = new OutputLine(this);\n                lines.push(this.current_line);\n                return true;\n            }\n\n            return false;\n        }\n\n        // initialize\n        this.add_new_line(true);\n\n        this.get_code = function() {\n            var sweet_code = lines.join('\\n').replace(/[\\r\\n\\t ]+$/, '');\n            return sweet_code;\n        }\n\n        this.set_indent = function(level) {\n            // Never indent your first output indent at the start of the file\n            if (lines.length > 1) {\n                while(level >= this.indent_cache.length) {\n                    this.indent_cache.push(this.indent_cache[this.indent_cache.length - 1] + this.indent_string);\n                }\n\n                this.current_line.set_indent(level);\n                return true;\n            }\n            this.current_line.set_indent(0);\n            return false;\n        }\n\n        this.add_token = function(printable_token) {\n            this.add_space_before_token();\n            this.current_line.push(printable_token);\n        }\n\n        this.add_space_before_token = function() {\n            if (this.space_before_token && !this.just_added_newline()) {\n                this.current_line.push(' ');\n            }\n            this.space_before_token = false;\n        }\n\n        this.remove_redundant_indentation = function (frame) {\n            // This implementation is effective but has some issues:\n            //     - can cause line wrap to happen too soon due to indent removal\n            //           after wrap points are calculated\n            // These issues are minor compared to ugly indentation.\n\n            if (frame.multiline_frame ||\n                frame.mode === MODE.ForInitializer ||\n                frame.mode === MODE.Conditional) {\n                return;\n            }\n\n            // remove one indent from each line inside this section\n            var index = frame.start_line_index;\n            var line;\n\n            var output_length = lines.length;\n            while (index < output_length) {\n                lines[index].remove_indent();\n                index++;\n            }\n        }\n\n        this.trim = function(eat_newlines) {\n            eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;\n\n            this.current_line.trim(indent_string, baseIndentString);\n\n            while (eat_newlines && lines.length > 1 &&\n                this.current_line.is_empty()) {\n                lines.pop();\n                this.current_line = lines[lines.length - 1]\n                this.current_line.trim();\n            }\n        }\n\n        this.just_added_newline = function() {\n            return this.current_line.is_empty();\n        }\n\n        this.just_added_blankline = function() {\n            if (this.just_added_newline()) {\n                if (lines.length === 1) {\n                    return true; // start of the file and newline = blank\n                }\n\n                var line = lines[lines.length - 2];\n                return line.is_empty();\n            }\n            return false;\n        }\n    }\n\n\n    var Token = function(type, text, newlines, whitespace_before, mode, parent) {\n        this.type = type;\n        this.text = text;\n        this.comments_before = [];\n        this.newlines = newlines || 0;\n        this.wanted_newline = newlines > 0;\n        this.whitespace_before = whitespace_before || '';\n        this.parent = null;\n    }\n\n    function tokenizer(input, opts, indent_string) {\n\n        var whitespace = \"\\n\\r\\t \".split('');\n        var digit = /[0-9]/;\n\n        var punct = ('+ - * / % & ++ -- = += -= *= /= %= == === != !== > < >= <= >> << >>> >>>= >>= <<= && &= | || ! ~ , : ? ^ ^= |= :: =>'\n                +' <%= <% %> <?= <? ?>').split(' '); // try to be a good boy and try not to break the markup language identifiers\n\n        // words which should always start on new line.\n        this.line_starters = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,yield,import,export'.split(',');\n        var reserved_words = this.line_starters.concat(['do', 'in', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof']);\n\n        var n_newlines, whitespace_before_token, in_html_comment, tokens, parser_pos;\n        var input_length;\n\n        this.tokenize = function() {\n            // cache the source's length.\n            input_length = input.length\n            parser_pos = 0;\n            in_html_comment = false\n            tokens = [];\n\n            var next, last;\n            var token_values;\n            var open = null;\n            var open_stack = [];\n            var comments = [];\n\n            while (!(last && last.type === 'TK_EOF')) {\n                token_values = tokenize_next();\n                next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token);\n                while(next.type === 'TK_INLINE_COMMENT' || next.type === 'TK_COMMENT' ||\n                    next.type === 'TK_BLOCK_COMMENT' || next.type === 'TK_UNKNOWN') {\n                    comments.push(next);\n                    token_values = tokenize_next();\n                    next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token);\n                }\n\n                if (comments.length) {\n                    next.comments_before = comments;\n                    comments = [];\n                }\n\n                if (next.type === 'TK_START_BLOCK' || next.type === 'TK_START_EXPR') {\n                    next.parent = last;\n                    open = next;\n                    open_stack.push(next);\n                }  else if ((next.type === 'TK_END_BLOCK' || next.type === 'TK_END_EXPR') &&\n                    (open && (\n                        (next.text === ']' && open.text === '[') ||\n                        (next.text === ')' && open.text === '(') ||\n                        (next.text === '}' && open.text === '}')))) {\n                    next.parent = open.parent;\n                    open = open_stack.pop();\n                }\n\n                tokens.push(next);\n                last = next;\n            }\n\n            return tokens;\n        }\n\n        function tokenize_next() {\n            var i, resulting_string;\n            var whitespace_on_this_line = [];\n\n            n_newlines = 0;\n            whitespace_before_token = '';\n\n            if (parser_pos >= input_length) {\n                return ['', 'TK_EOF'];\n            }\n\n            var last_token;\n            if (tokens.length) {\n                last_token = tokens[tokens.length-1];\n            } else {\n                // For the sake of tokenizing we can pretend that there was on open brace to start\n                last_token = new Token('TK_START_BLOCK', '{');\n            }\n\n\n            var c = input.charAt(parser_pos);\n            parser_pos += 1;\n\n            while (in_array(c, whitespace)) {\n\n                if (c === '\\n') {\n                    n_newlines += 1;\n                    whitespace_on_this_line = [];\n                } else if (n_newlines) {\n                    if (c === indent_string) {\n                        whitespace_on_this_line.push(indent_string);\n                    } else if (c !== '\\r') {\n                        whitespace_on_this_line.push(' ');\n                    }\n                }\n\n                if (parser_pos >= input_length) {\n                    return ['', 'TK_EOF'];\n                }\n\n                c = input.charAt(parser_pos);\n                parser_pos += 1;\n            }\n\n            if(whitespace_on_this_line.length) {\n                whitespace_before_token = whitespace_on_this_line.join('');\n            }\n\n            if (digit.test(c)) {\n                var allow_decimal = true;\n                var allow_e = true;\n                var local_digit = digit;\n\n                if (c === '0' && parser_pos < input_length && /[Xx]/.test(input.charAt(parser_pos))) {\n                    // switch to hex number, no decimal or e, just hex digits\n                    allow_decimal = false;\n                    allow_e = false;\n                    c += input.charAt(parser_pos);\n                    parser_pos += 1;\n                    local_digit = /[0123456789abcdefABCDEF]/\n                } else {\n                    // we know this first loop will run.  It keeps the logic simpler.\n                    c = '';\n                    parser_pos -= 1\n                }\n\n                // Add the digits\n                while (parser_pos < input_length && local_digit.test(input.charAt(parser_pos))) {\n                    c += input.charAt(parser_pos);\n                    parser_pos += 1;\n\n                    if (allow_decimal && parser_pos < input_length && input.charAt(parser_pos) === '.') {\n                        c += input.charAt(parser_pos);\n                        parser_pos += 1;\n                        allow_decimal = false;\n                    }\n\n                    if (allow_e && parser_pos < input_length && /[Ee]/.test(input.charAt(parser_pos))) {\n                        c += input.charAt(parser_pos);\n                        parser_pos += 1;\n\n                        if (parser_pos < input_length && /[+-]/.test(input.charAt(parser_pos))) {\n                            c += input.charAt(parser_pos);\n                            parser_pos += 1;\n                        }\n\n                        allow_e = false;\n                        allow_decimal = false;\n                    }\n                }\n\n                return [c, 'TK_WORD'];\n            }\n\n            if (acorn.isIdentifierStart(input.charCodeAt(parser_pos-1))) {\n                if (parser_pos < input_length) {\n                    while (acorn.isIdentifierChar(input.charCodeAt(parser_pos))) {\n                        c += input.charAt(parser_pos);\n                        parser_pos += 1;\n                        if (parser_pos === input_length) {\n                            break;\n                        }\n                    }\n                }\n\n                if (!(last_token.type === 'TK_DOT' ||\n                        (last_token.type === 'TK_RESERVED' && in_array(last_token.text, ['set', 'get'])))\n                    && in_array(c, reserved_words)) {\n                    if (c === 'in') { // hack for 'in' operator\n                        return [c, 'TK_OPERATOR'];\n                    }\n                    return [c, 'TK_RESERVED'];\n                }\n\n                return [c, 'TK_WORD'];\n            }\n\n            if (c === '(' || c === '[') {\n                return [c, 'TK_START_EXPR'];\n            }\n\n            if (c === ')' || c === ']') {\n                return [c, 'TK_END_EXPR'];\n            }\n\n            if (c === '{') {\n                return [c, 'TK_START_BLOCK'];\n            }\n\n            if (c === '}') {\n                return [c, 'TK_END_BLOCK'];\n            }\n\n            if (c === ';') {\n                return [c, 'TK_SEMICOLON'];\n            }\n\n            if (c === '/') {\n                var comment = '';\n                // peek for comment /* ... */\n                var inline_comment = true;\n                if (input.charAt(parser_pos) === '*') {\n                    parser_pos += 1;\n                    if (parser_pos < input_length) {\n                        while (parser_pos < input_length && !(input.charAt(parser_pos) === '*' && input.charAt(parser_pos + 1) && input.charAt(parser_pos + 1) === '/')) {\n                            c = input.charAt(parser_pos);\n                            comment += c;\n                            if (c === \"\\n\" || c === \"\\r\") {\n                                inline_comment = false;\n                            }\n                            parser_pos += 1;\n                            if (parser_pos >= input_length) {\n                                break;\n                            }\n                        }\n                    }\n                    parser_pos += 2;\n                    if (inline_comment && n_newlines === 0) {\n                        return ['/*' + comment + '*/', 'TK_INLINE_COMMENT'];\n                    } else {\n                        return ['/*' + comment + '*/', 'TK_BLOCK_COMMENT'];\n                    }\n                }\n                // peek for comment // ...\n                if (input.charAt(parser_pos) === '/') {\n                    comment = c;\n                    while (input.charAt(parser_pos) !== '\\r' && input.charAt(parser_pos) !== '\\n') {\n                        comment += input.charAt(parser_pos);\n                        parser_pos += 1;\n                        if (parser_pos >= input_length) {\n                            break;\n                        }\n                    }\n                    return [comment, 'TK_COMMENT'];\n                }\n\n            }\n\n            if (c === '`' || c === \"'\" || c === '\"' || // string\n                (\n                    (c === '/') || // regexp\n                    (opts.e4x && c === \"<\" && input.slice(parser_pos - 1).match(/^<([-a-zA-Z:0-9_.]+|{[^{}]*}|!\\[CDATA\\[[\\s\\S]*?\\]\\])\\s*([-a-zA-Z:0-9_.]+=('[^']*'|\"[^\"]*\"|{[^{}]*})\\s*)*\\/?\\s*>/)) // xml\n                ) && ( // regex and xml can only appear in specific locations during parsing\n                    (last_token.type === 'TK_RESERVED' && in_array(last_token.text , ['return', 'case', 'throw', 'else', 'do', 'typeof', 'yield'])) ||\n                    (last_token.type === 'TK_END_EXPR' && last_token.text === ')' &&\n                        last_token.parent && last_token.parent.type === 'TK_RESERVED' && in_array(last_token.parent.text, ['if', 'while', 'for'])) ||\n                    (in_array(last_token.type, ['TK_COMMENT', 'TK_START_EXPR', 'TK_START_BLOCK',\n                        'TK_END_BLOCK', 'TK_OPERATOR', 'TK_EQUALS', 'TK_EOF', 'TK_SEMICOLON', 'TK_COMMA'\n                    ]))\n                )) {\n\n                var sep = c,\n                    esc = false,\n                    has_char_escapes = false;\n\n                resulting_string = c;\n\n                if (sep === '/') {\n                    //\n                    // handle regexp\n                    //\n                    var in_char_class = false;\n                    while (parser_pos < input_length &&\n                            ((esc || in_char_class || input.charAt(parser_pos) !== sep) &&\n                            !acorn.newline.test(input.charAt(parser_pos)))) {\n                        resulting_string += input.charAt(parser_pos);\n                        if (!esc) {\n                            esc = input.charAt(parser_pos) === '\\\\';\n                            if (input.charAt(parser_pos) === '[') {\n                                in_char_class = true;\n                            } else if (input.charAt(parser_pos) === ']') {\n                                in_char_class = false;\n                            }\n                        } else {\n                            esc = false;\n                        }\n                        parser_pos += 1;\n                    }\n                } else if (opts.e4x && sep === '<') {\n                    //\n                    // handle e4x xml literals\n                    //\n                    var xmlRegExp = /<(\\/?)([-a-zA-Z:0-9_.]+|{[^{}]*}|!\\[CDATA\\[[\\s\\S]*?\\]\\])\\s*([-a-zA-Z:0-9_.]+=('[^']*'|\"[^\"]*\"|{[^{}]*})\\s*)*(\\/?)\\s*>/g;\n                    var xmlStr = input.slice(parser_pos - 1);\n                    var match = xmlRegExp.exec(xmlStr);\n                    if (match && match.index === 0) {\n                        var rootTag = match[2];\n                        var depth = 0;\n                        while (match) {\n                            var isEndTag = !! match[1];\n                            var tagName = match[2];\n                            var isSingletonTag = ( !! match[match.length - 1]) || (tagName.slice(0, 8) === \"![CDATA[\");\n                            if (tagName === rootTag && !isSingletonTag) {\n                                if (isEndTag) {\n                                    --depth;\n                                } else {\n                                    ++depth;\n                                }\n                            }\n                            if (depth <= 0) {\n                                break;\n                            }\n                            match = xmlRegExp.exec(xmlStr);\n                        }\n                        var xmlLength = match ? match.index + match[0].length : xmlStr.length;\n                        parser_pos += xmlLength - 1;\n                        return [xmlStr.slice(0, xmlLength), \"TK_STRING\"];\n                    }\n                } else {\n                    //\n                    // handle string\n                    //\n                    // Template strings can travers lines without escape characters.\n                    // Other strings cannot\n                    while (parser_pos < input_length &&\n                            (esc || (input.charAt(parser_pos) !== sep &&\n                            (sep === '`' || !acorn.newline.test(input.charAt(parser_pos)))))) {\n                        resulting_string += input.charAt(parser_pos);\n                        if (esc) {\n                            if (input.charAt(parser_pos) === 'x' || input.charAt(parser_pos) === 'u') {\n                                has_char_escapes = true;\n                            }\n                            esc = false;\n                        } else {\n                            esc = input.charAt(parser_pos) === '\\\\';\n                        }\n                        parser_pos += 1;\n                    }\n\n                }\n\n                if (has_char_escapes && opts.unescape_strings) {\n                    resulting_string = unescape_string(resulting_string);\n                }\n\n                if (parser_pos < input_length && input.charAt(parser_pos) === sep) {\n                    resulting_string += sep;\n                    parser_pos += 1;\n\n                    if (sep === '/') {\n                        // regexps may have modifiers /regexp/MOD , so fetch those, too\n                        // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.\n                        while (parser_pos < input_length && acorn.isIdentifierStart(input.charCodeAt(parser_pos))) {\n                            resulting_string += input.charAt(parser_pos);\n                            parser_pos += 1;\n                        }\n                    }\n                }\n                return [resulting_string, 'TK_STRING'];\n            }\n\n            if (c === '#') {\n\n                if (tokens.length === 0 && input.charAt(parser_pos) === '!') {\n                    // shebang\n                    resulting_string = c;\n                    while (parser_pos < input_length && c !== '\\n') {\n                        c = input.charAt(parser_pos);\n                        resulting_string += c;\n                        parser_pos += 1;\n                    }\n                    return [trim(resulting_string) + '\\n', 'TK_UNKNOWN'];\n                }\n\n\n\n                // Spidermonkey-specific sharp variables for circular references\n                // https://developer.mozilla.org/En/Sharp_variables_in_JavaScript\n                // http://mxr.mozilla.org/mozilla-central/source/js/src/jsscan.cpp around line 1935\n                var sharp = '#';\n                if (parser_pos < input_length && digit.test(input.charAt(parser_pos))) {\n                    do {\n                        c = input.charAt(parser_pos);\n                        sharp += c;\n                        parser_pos += 1;\n                    } while (parser_pos < input_length && c !== '#' && c !== '=');\n                    if (c === '#') {\n                        //\n                    } else if (input.charAt(parser_pos) === '[' && input.charAt(parser_pos + 1) === ']') {\n                        sharp += '[]';\n                        parser_pos += 2;\n                    } else if (input.charAt(parser_pos) === '{' && input.charAt(parser_pos + 1) === '}') {\n                        sharp += '{}';\n                        parser_pos += 2;\n                    }\n                    return [sharp, 'TK_WORD'];\n                }\n            }\n\n            if (c === '<' && input.substring(parser_pos - 1, parser_pos + 3) === '<!--') {\n                parser_pos += 3;\n                c = '<!--';\n                while (input.charAt(parser_pos) !== '\\n' && parser_pos < input_length) {\n                    c += input.charAt(parser_pos);\n                    parser_pos++;\n                }\n                in_html_comment = true;\n                return [c, 'TK_COMMENT'];\n            }\n\n            if (c === '-' && in_html_comment && input.substring(parser_pos - 1, parser_pos + 2) === '-->') {\n                in_html_comment = false;\n                parser_pos += 2;\n                return ['-->', 'TK_COMMENT'];\n            }\n\n            if (c === '.') {\n                return [c, 'TK_DOT'];\n            }\n\n            if (in_array(c, punct)) {\n                while (parser_pos < input_length && in_array(c + input.charAt(parser_pos), punct)) {\n                    c += input.charAt(parser_pos);\n                    parser_pos += 1;\n                    if (parser_pos >= input_length) {\n                        break;\n                    }\n                }\n\n                if (c === ',') {\n                    return [c, 'TK_COMMA'];\n                } else if (c === '=') {\n                    return [c, 'TK_EQUALS'];\n                } else {\n                    return [c, 'TK_OPERATOR'];\n                }\n            }\n\n            return [c, 'TK_UNKNOWN'];\n        }\n\n\n        function unescape_string(s) {\n            var esc = false,\n                out = '',\n                pos = 0,\n                s_hex = '',\n                escaped = 0,\n                c;\n\n            while (esc || pos < s.length) {\n\n                c = s.charAt(pos);\n                pos++;\n\n                if (esc) {\n                    esc = false;\n                    if (c === 'x') {\n                        // simple hex-escape \\x24\n                        s_hex = s.substr(pos, 2);\n                        pos += 2;\n                    } else if (c === 'u') {\n                        // unicode-escape, \\u2134\n                        s_hex = s.substr(pos, 4);\n                        pos += 4;\n                    } else {\n                        // some common escape, e.g \\n\n                        out += '\\\\' + c;\n                        continue;\n                    }\n                    if (!s_hex.match(/^[0123456789abcdefABCDEF]+$/)) {\n                        // some weird escaping, bail out,\n                        // leaving whole string intact\n                        return s;\n                    }\n\n                    escaped = parseInt(s_hex, 16);\n\n                    if (escaped >= 0x00 && escaped < 0x20) {\n                        // leave 0x00...0x1f escaped\n                        if (c === 'x') {\n                            out += '\\\\x' + s_hex;\n                        } else {\n                            out += '\\\\u' + s_hex;\n                        }\n                        continue;\n                    } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {\n                        // single-quote, apostrophe, backslash - escape these\n                        out += '\\\\' + String.fromCharCode(escaped);\n                    } else if (c === 'x' && escaped > 0x7e && escaped <= 0xff) {\n                        // we bail out on \\x7f..\\xff,\n                        // leaving whole string escaped,\n                        // as it's probably completely binary\n                        return s;\n                    } else {\n                        out += String.fromCharCode(escaped);\n                    }\n                } else if (c === '\\\\') {\n                    esc = true;\n                } else {\n                    out += c;\n                }\n            }\n            return out;\n        }\n\n    }\n\n    return { js_beautify: js_beautify };\n});\n"]}