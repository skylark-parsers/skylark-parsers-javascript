{"version":3,"sources":["primitives/acorn.js"],"names":["define","isInAstralSet","code","set","pos","i","length","isIdentifierStart","astral","nonASCIIidentifierStart","test","String","fromCharCode","astralIdentifierStartCodes","isIdentifierChar","nonASCIIidentifier","astralIdentifierCodes","binop","name","prec","TokenType","beforeExpr","kw","options","keyword","keywords$1","isNewLine","ecma2019String","has","obj","propName","hasOwnProperty","call","getLineInfo","input","offset","line","cur","lineBreakG","lastIndex","match","exec","index","Position","getOptions","opts","opt","defaultOptions","ecmaVersion","allowReserved","isArray","onToken","tokens","token","push","onComment","pushComment","array","block","text","start","end","startLoc","endLoc","comment","type","value","locations","loc","SourceLocation","this","ranges","range","keywordRegexp","words","RegExp","replace","DestructuringErrors","shorthandAssign","trailingComma","parenthesizedAssign","parenthesizedBind","doubleProto","finishNodeAt","node","codePointToString$1","ch","isSyntaxCharacter","isRegExpIdentifierStart","isRegExpIdentifierPart","isControlLetter","isValidUnicode","isCharacterClassEscape","isUnicodePropertyNameCharacter","isUnicodePropertyValueCharacter","isDecimalDigit","isHexDigit","hexToInt","isOctalDigit","codePointToString","parse","Parser","parseExpressionAt","p","nextToken","parseExpression","tokenizer","addLooseExports","Parser$$1","plugins$$1","exports","parse_dammit","LooseParser","pluginsLoose","reservedWords","3","5","6","strict","strictBind","ecma5AndLessKeywords","keywords","keywordRelationalOperator","nonASCIIidentifierStartChars","nonASCIIidentifierChars","label","conf","startsExpr","isLoop","isAssign","prefix","postfix","updateContext","types","num","regexp","string","eof","bracketL","bracketR","braceL","braceR","parenL","parenR","comma","semi","colon","dot","question","arrow","template","invalidTemplate","ellipsis","backQuote","dollarBraceL","eq","assign","incDec","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","modulo","star","slash","starstar","_break","_case","_catch","_continue","_debugger","_default","_do","_else","_finally","_for","_function","_if","_return","_switch","_throw","_try","_var","_const","_while","_with","_new","_this","_super","_class","_extends","_export","_import","_null","_true","_false","_in","_instanceof","_typeof","_void","_delete","lineBreak","source","nonASCIIwhitespace","skipWhiteSpace","ref","Object","prototype","toString","Array","col","column","n","sourceFile","sourceType","onInsertedSemicolon","onTrailingComma","allowReturnOutsideFunction","allowImportExportEverywhere","allowAwaitOutsideFunction","allowHashBang","program","directSourceFile","preserveParens","plugins","startPos","reserved","v","reservedStrict","reservedWordsStrict","reservedWordsStrictBind","containsEsc","loadPlugins","lineStart","lastIndexOf","curLine","slice","split","curPosition","lastTokEndLoc","lastTokStartLoc","lastTokStart","lastTokEnd","context","initialContext","exprAllowed","inModule","strictDirective","potentialArrowAt","inFunction","inGenerator","inAsync","yieldPos","awaitPos","labels","skipLineComment","scopeStack","enterFunctionScope","regexpState","isKeyword","word","isReservedWord","extend","f","pluginConfigs","this$1","plugin","Error","startNode","parseTopLevel","pp","literal","eat","next","isContextual","eatContextual","expectContextual","unexpected","canInsertSemicolon","insertSemicolon","semicolon","afterTrailingComma","tokType","notNext","expect","raise","checkPatternErrors","refDestructuringErrors","raiseRecoverable","parens","checkExpressionErrors","andThrow","checkYieldAwaitInDefaultParams","isSimpleAssignTarget","expr","expression","pp$1","body","stmt","parseStatement","adaptDirectivePrologue","finishNode","loopLabel","kind","switchLabel","isLet","skip","nextCh","charCodeAt","ident","isAsyncFunction","charAt","declaration","topLevel","starttype","parseBreakContinueStatement","parseDebuggerStatement","parseDoStatement","parseForStatement","parseFunctionStatement","parseClass","parseIfStatement","parseReturnStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseVarStatement","parseWhileStatement","parseWithStatement","parseBlock","parseEmptyStatement","parseImport","parseExport","maybeName","parseLabeledStatement","parseExpressionStatement","isBreak","parseIdent","lab","pop","parseParenExpression","awaitAt","enterLexicalScope","parseFor","init$1","parseVar","declarations","init","await","parseForIn","toAssignable","checkLVal","isAsync","parseFunction","consequent","alternate","argument","discriminant","cases","sawDefault","isCase","exitLexicalScope","empty","handler","clause","param","parseBindingAtom","finalizer","object","i$1","list","label$1","statementStart","generator","async","createNewLexicalScope","update","id","left","right","parseMaybeAssign","isFor","decl","parseVarId","isStatement","allowExpressionBody","initFunction","oldInGen","oldInAsync","oldYieldPos","oldAwaitPos","oldInFunc","parseFunctionParams","parseFunctionBody","params","parseBindingList","parseClassId","parseClassSuper","classBody","hadConstructor","member","parseClassMember","method","tryContextual","k","noLineBreak","key","computed","startNodeAt","isGenerator","parsePropertyName","parseClassMethod","parseMethod","superClass","parseExprSubscripts","parseExprAtom","checkExport","fNode","cNode","shouldParseExportStatement","checkVariableExport","specifiers","parseExportSpecifiers","spec","checkUnreserved","local","checkPatternExport","pat","properties","prop","list$1","elements","elt","decls","nodes","first","exported","parseImportSpecifiers","node$1","node$2","imported","statements","isDirectiveCandidate","directive","raw","statement","pp$2","isBinding","toAssignableList","operator","exprList","last","parseSpread","parseRestBinding","parseObj","close","allowEmpty","allowTrailingComma","elts","rest","parseBindingListItem","elem","parseMaybeDefault","bindingType","checkClashes","canDeclareVarName","canDeclareLexicalName","declareVarName","declareLexicalName","pp$3","checkPropClash","propHash","shorthand","proto","other","redefinition","get","noIn","expressions","afterLeftParse","parseYield","ownDestructuringErrors","oldParenAssign","oldTrailingComma","parseMaybeConditional","parseExprOps","parseMaybeUnary","parseExprOp","leftStartPos","leftStartLoc","minPrec","logical","op","buildBinary","sawUnary","parseAwait","skipArrowSubscripts","result","parseSubscripts","base","noCalls","maybeAsyncArrow","property","parseExprList","parseArrowExpression","callee","arguments","tag","quasi","parseTemplate","isTagged","canBeArrow","parseLiteral","regex","pattern","flags","parseParenAndDistinguishExpression","parseNew","val","spreadStart","innerStartPos","innerStartLoc","lastIsComma","parseParenItem","innerEndPos","innerEndLoc","parseParenArrowList","par","item","empty$1","meta","parseTemplateElement","cooked","tail","curElt","quasis","isAsyncProp","isPattern","parseProperty","parsePropertyValue","paramCount","isArrowFunction","isExpression","oldStrict","useStrict","checkParams","nonSimple","isSimpleParamList","oldLabels","exitFunctionScope","allowDuplicates","nameHash","indexOf","re","liberal","delegate","pp$4","message","err","SyntaxError","raisedAt","pp$5","target","sources","len","var","lexical","childVar","parentLexical","parentScope","childScope","currentScope","Node","parser","pp$6","TokContext","isExpr","preserveSpace","override","types$1","b_stat","b_expr","b_tmpl","p_stat","p_expr","q_tmpl","tryReadTemplateToken","f_stat","f_expr","f_expr_gen","f_gen","pp$7","braceIsBlock","prevType","parent","curContext","inGeneratorContext","out","statementParens","allowed","data","$LONE","General_Category","Script","apply","gc","sc","Script_Extensions","scx","pp$9","RegExpValidationState","validFlags","switchU","switchN","lastIntValue","lastStringValue","lastAssertionIsQuantifiable","numCapturingParens","maxBackReference","groupNames","backReferenceNames","reset","unicode","at","s","l","c","nextIndex","current","lookahead","advance","validateRegExpFlags","state","flag","validateRegExpPattern","regexp_pattern","regexp_disjunction","regexp_alternative","regexp_eatQuantifier","regexp_eatTerm","regexp_eatAssertion","regexp_eatAtom","regexp_eatExtendedAtom","lookbehind","noError","regexp_eatQuantifierPrefix","regexp_eatBracedQuantifier","min","max","regexp_eatDecimalDigits","regexp_eatPatternCharacters","regexp_eatReverseSolidusAtomEscape","regexp_eatCharacterClass","regexp_eatUncapturingGroup","regexp_eatCapturingGroup","regexp_eatAtomEscape","regexp_groupSpecifier","regexp_eatInvalidBracedQuantifier","regexp_eatExtendedPatternCharacter","regexp_eatSyntaxCharacter","regexp_eatGroupName","regexp_eatRegExpIdentifierName","regexp_eatRegExpIdentifierStart","regexp_eatRegExpIdentifierPart","regexp_eatRegExpUnicodeEscapeSequence","regexp_eatBackReference","regexp_eatCharacterClassEscape","regexp_eatCharacterEscape","regexp_eatKGroupName","regexp_eatDecimalEscape","regexp_eatControlEscape","regexp_eatCControlLetter","regexp_eatZero","regexp_eatHexEscapeSequence","regexp_eatLegacyOctalEscapeSequence","regexp_eatIdentityEscape","regexp_eatControlLetter","regexp_eatFixedHexDigits","lead","leadSurrogateEnd","trail","regexp_eatHexDigits","regexp_eatUnicodePropertyValueExpression","regexp_eatUnicodePropertyName","regexp_eatUnicodePropertyValue","regexp_validateUnicodePropertyNameAndValue","regexp_eatLoneUnicodePropertyNameOrValue","nameOrValue","regexp_validateUnicodePropertyNameOrValue","regexp_classRanges","regexp_eatClassAtom","regexp_eatClassEscape","ch$1","regexp_eatClassControlLetter","regexp_eatOctalDigit","n1","n2","Token","pp$8","getToken","Symbol","iterator","done","skipSpace","finishToken","readToken","fullCharCodeAtPos","readWord","getTokenFromCode","skipBlockComment","startSkip","loop","readToken_dot","readNumber","next2","readToken_slash","readRegexp","finishOp","readToken_mult_modulo_exp","size","tokentype","readToken_pipe_amp","readToken_caret","readToken_plus_min","readToken_lt_gt","readToken_eq_excl","readRadixNumber","readString","str","escaped","inClass","flagsStart","readWord1","e","readInt","radix","total","Infinity","startsWithDot","octal","parseInt","parseFloat","readCodePoint","codePos","readHexChar","invalidStringToken","quote","chunkStart","readEscapedChar","INVALID_TEMPLATE_ESCAPE_ERROR","inTemplateElement","readTmplToken","readInvalidTemplateToken","position","inTemplate","octalStr","substr","escStart","esc","version","tokTypes","keywordTypes","tokContexts","defineProperty"],"mappings":"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EAAE,EAAE,IAAI,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,IAAI,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,IAAI,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,GAAG,GAAG,EAAE,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,KAAK,KAAK,KAAK,IAAI,KAAK,IAAI,EAAE,GAAG,IAAI,GAAG,GAAG,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,GAAG,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,KAAK,GAAG,IAAI,KAAK,IAAI,GAAG,IAAI,KAAK,IAAI,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,KAAK,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,KAAK,IAAI,GAAG,GAAG,KAAK,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,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M,GAAS8hB,GAAQW,MAEpC7gB,KAAKoL,aAAc,GAGrBrH,EAAMnH,KAAKkH,cAAgB,SAASkd,GAClC,GAAIM,IAAU,CACVthB,MAAK/C,QAAQyB,aAAe,IACX,OAAfsB,KAAKJ,QAAmBI,KAAKoL,aACd,UAAfpL,KAAKJ,OAAqBI,KAAKmhB,wBAC/BG,GAAU,GAEhBthB,KAAKoL,YAAckW,EAGrB,IAAIC,KACFC,OACE,QACA,kBACA,OACA,aACA,QACA,MACA,WACA,eACA,SACA,gBACA,SACA,iBACA,KACA,QACA,0BACA,OACA,0BACA,OACA,0BACA,MACA,+BACA,QACA,0BACA,MACA,0BACA,MACA,OACA,+BACA,KACA,aACA,MACA,YACA,MACA,QACA,kBACA,iBACA,sBACA,qBACA,WACA,MACA,gBACA,UACA,kBACA,SACA,YACA,MACA,sBACA,OACA,uBACA,OACA,cACA,MACA,WACA,MACA,cACA,OACA,eACA,SACA,0BACA,MACA,YACA,QACA,OACA,0BACA,QACA,iBACA,UACA,sBACA,SACA,iBACA,QACA,UACA,qBACA,KACA,oBACA,QACA,cACA,KACA,uBACA,OACA,oBACA,QACA,YACA,QACA,qBACA,KACA,cACA,QACA,eACA,OACA,YACA,QAEFC,kBACE,eACA,KACA,oBACA,KACA,wBACA,KACA,UACA,KACA,QACA,kBACA,KACA,mBACA,KACA,iBACA,KACA,QACA,iBACA,KACA,oBACA,KACA,SACA,KACA,sBACA,KACA,SACA,IACA,gBACA,KACA,iBACA,KACA,mBACA,KACA,OACA,IACA,iBACA,cACA,KACA,kBACA,KACA,kBACA,KACA,kBACA,KACA,SACA,IACA,mBACA,KACA,QACA,IACA,eACA,KACA,eACA,KACA,oBACA,KACA,eACA,KACA,sBACA,KACA,cACA,KACA,cACA,IACA,QACA,YACA,IACA,kBACA,KACA,eACA,KACA,YACA,KACA,SACA,IACA,mBACA,KACA,aACA,KACA,mBACA,MAEFC,QACE,QACA,OACA,OACA,wBACA,OACA,SACA,OACA,WACA,OACA,UACA,OACA,WACA,OACA,QACA,OACA,YACA,OACA,QACA,OACA,UACA,OACA,YACA,OACA,WACA,OACA,SACA,OACA,UACA,OACA,WACA,OACA,QACA,OACA,sBACA,OACA,SACA,OACA,qBACA,OACA,SACA,OACA,OACA,WACA,OACA,SACA,OACA,SACA,OACA,OACA,YACA,OACA,UACA,OACA,WACA,OACA,UACA,OACA,aACA,OACA,WACA,OACA,uBACA,OACA,UACA,OACA,WACA,OACA,WACA,OACA,aACA,OACA,SACA,OACA,UACA,OACA,QACA,OACA,WACA,OACA,WACA,OACA,MACA,OACA,SACA,OACA,UACA,OACA,SACA,OACA,SACA,OACA,WACA,OACA,mBACA,OACA,YACA,OACA,OACA,wBACA,OACA,yBACA,OACA,WACA,OACA,SACA,OACA,UACA,OACA,WACA,OACA,WACA,OACA,aACA,OACA,QACA,OACA,SACA,OACA,YACA,OACA,MACA,OACA,QACA,OACA,SACA,OACA,QACA,OACA,WACA,OACA,WACA,OACA,OACA,SACA,OACA,SACA,OACA,WACA,OACA,YACA,OACA,UACA,OACA,aACA,OACA,UACA,OACA,gBACA,OACA,eACA,OACA,gBACA,OACA,mBACA,OACA,uBACA,OACA,OACA,OACA,OACA,YACA,OACA,MACA,OACA,UACA,OACA,UACA,OACA,YACA,OACA,cACA,OACA,OACA,MACA,OACA,QACA,OACA,QACA,OACA,WACA,OACA,gBACA,OACA,aACA,OACA,oBACA,OACA,aACA,OACA,cACA,OACA,oBACA,OACA,aACA,OACA,QACA,OACA,QACA,OACA,UACA,OACA,eACA,OACA,YACA,OACA,cACA,OACA,WACA,OACA,aACA,OACA,kBACA,OACA,SACA,OACA,QACA,OACA,YACA,OACA,aACA,OACA,UACA,OACA,UACA,OACA,UACA,OACA,cACA,OACA,UACA,OACA,eACA,OACA,UACA,OACA,YACA,OACA,eACA,OACA,SACA,OACA,UACA,OACA,WACA,OAC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","file":"../../primitives/acorn.js","sourcesContent":["define([],function(){\r\n\r\n\r\n'use strict';\r\n\r\nvar exports = {};\r\n\r\n// Reserved word lists for various dialects of the language\r\n\r\nvar reservedWords = {\r\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\r\n  5: \"class enum extends super const export import\",\r\n  6: \"enum\",\r\n  strict: \"implements interface let package private protected public static yield\",\r\n  strictBind: \"eval arguments\"\r\n};\r\n\r\n// And the keywords\r\n\r\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\r\n\r\nvar keywords = {\r\n  5: ecma5AndLessKeywords,\r\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\r\n};\r\n\r\nvar keywordRelationalOperator = /^in(stanceof)?$/;\r\n\r\n// ## Character categories\r\n\r\n// Big ugly regular expressions that match characters in the\r\n// whitespace, identifier, and identifier-start categories. These\r\n// are only applied when a character is found to actually have a\r\n// code point above 128.\r\n// Generated by `bin/generate-identifier-regex.js`.\r\n\r\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fef\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7b9\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab65\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\r\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\r\n\r\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\r\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\r\n\r\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\r\n\r\n// These are a run-length and offset encoded representation of the\r\n// >0xffff code points that are a valid part of identifiers. The\r\n// offset starts at 0x10000, and each pair of numbers represents an\r\n// offset to the next range, and then a size of the range. They were\r\n// generated by bin/generate-identifier-regex.js\r\n\r\n// eslint-disable-next-line comma-spacing\r\nvar astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,190,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,26,230,43,117,63,32,0,257,0,11,39,8,0,22,0,12,39,3,3,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,68,12,0,67,12,65,1,31,6129,15,754,9486,286,82,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];\r\n\r\n// eslint-disable-next-line comma-spacing\r\nvar astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,280,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239];\r\n\r\n// This has a complexity linear to the value of the code. The\r\n// assumption is that looking up astral identifier characters is\r\n// rare.\r\nfunction isInAstralSet(code, set) {\r\n  var pos = 0x10000;\r\n  for (var i = 0; i < set.length; i += 2) {\r\n    pos += set[i];\r\n    if (pos > code) { return false }\r\n    pos += set[i + 1];\r\n    if (pos >= code) { return true }\r\n  }\r\n}\r\n\r\n// Test whether a given character code starts an identifier.\r\n\r\nfunction isIdentifierStart(code, astral) {\r\n  if (code < 65) { return code === 36 }\r\n  if (code < 91) { return true }\r\n  if (code < 97) { return code === 95 }\r\n  if (code < 123) { return true }\r\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\r\n  if (astral === false) { return false }\r\n  return isInAstralSet(code, astralIdentifierStartCodes)\r\n}\r\n\r\n// Test whether a given character is part of an identifier.\r\n\r\nfunction isIdentifierChar(code, astral) {\r\n  if (code < 48) { return code === 36 }\r\n  if (code < 58) { return true }\r\n  if (code < 65) { return false }\r\n  if (code < 91) { return true }\r\n  if (code < 97) { return code === 95 }\r\n  if (code < 123) { return true }\r\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\r\n  if (astral === false) { return false }\r\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\r\n}\r\n\r\n// ## Token types\r\n\r\n// The assignment of fine-grained, information-carrying type objects\r\n// allows the tokenizer to store the information it has about a\r\n// token in a way that is very cheap for the parser to look up.\r\n\r\n// All token type variables start with an underscore, to make them\r\n// easy to recognize.\r\n\r\n// The `beforeExpr` property is used to disambiguate between regular\r\n// expressions and divisions. It is set on all token types that can\r\n// be followed by an expression (thus, a slash after them would be a\r\n// regular expression).\r\n//\r\n// The `startsExpr` property is used to check if the token ends a\r\n// `yield` expression. It is set on all token types that either can\r\n// directly start an expression (like a quotation mark) or can\r\n// continue an expression (like the body of a string).\r\n//\r\n  // `isLoop` marks a keyword as starting a loop, which is important\r\n  // to know when parsing a label, in order to allow or disallow\r\n  // continue jumps to that label.\r\n\r\n  var TokenType = function TokenType(label, conf) {\r\n    if ( conf === void 0 ) conf = {};\r\n\r\n    this.label = label;\r\n    this.keyword = conf.keyword;\r\n    this.beforeExpr = !!conf.beforeExpr;\r\n    this.startsExpr = !!conf.startsExpr;\r\n    this.isLoop = !!conf.isLoop;\r\n    this.isAssign = !!conf.isAssign;\r\n    this.prefix = !!conf.prefix;\r\n    this.postfix = !!conf.postfix;\r\n    this.binop = conf.binop || null;\r\n    this.updateContext = null;\r\n  };\r\n\r\n  function binop(name, prec) {\r\n    return new TokenType(name, {beforeExpr: true, binop: prec})\r\n  }\r\n  var beforeExpr = {beforeExpr: true};\r\n  var startsExpr = {startsExpr: true};\r\n\r\n  // Map keyword names to token types.\r\n\r\n  var keywords$1 = {};\r\n\r\n  // Succinct definitions of keyword token types\r\n  function kw(name, options) {\r\n    if ( options === void 0 ) options = {};\r\n\r\n    options.keyword = name;\r\n    return keywords$1[name] = new TokenType(name, options)\r\n  }\r\n\r\n  var types = {\r\n    num: new TokenType(\"num\", startsExpr),\r\n    regexp: new TokenType(\"regexp\", startsExpr),\r\n    string: new TokenType(\"string\", startsExpr),\r\n    name: new TokenType(\"name\", startsExpr),\r\n    eof: new TokenType(\"eof\"),\r\n\r\n    // Punctuation token types.\r\n    bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\r\n    bracketR: new TokenType(\"]\"),\r\n    braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\r\n    braceR: new TokenType(\"}\"),\r\n    parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\r\n    parenR: new TokenType(\")\"),\r\n    comma: new TokenType(\",\", beforeExpr),\r\n    semi: new TokenType(\";\", beforeExpr),\r\n    colon: new TokenType(\":\", beforeExpr),\r\n    dot: new TokenType(\".\"),\r\n    question: new TokenType(\"?\", beforeExpr),\r\n    arrow: new TokenType(\"=>\", beforeExpr),\r\n    template: new TokenType(\"template\"),\r\n    invalidTemplate: new TokenType(\"invalidTemplate\"),\r\n    ellipsis: new TokenType(\"...\", beforeExpr),\r\n    backQuote: new TokenType(\"`\", startsExpr),\r\n    dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\r\n\r\n    // Operators. These carry several kinds of properties to help the\r\n    // parser use them properly (the presence of these properties is\r\n    // what categorizes them as operators).\r\n    //\r\n    // `binop`, when present, specifies that this operator is a binary\r\n    // operator, and will refer to its precedence.\r\n    //\r\n    // `prefix` and `postfix` mark the operator as a prefix or postfix\r\n    // unary operator.\r\n    //\r\n    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\r\n    // binary operators with a very low precedence, that should result\r\n    // in AssignmentExpression nodes.\r\n\r\n    eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\r\n    assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\r\n    incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\r\n    prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\r\n    logicalOR: binop(\"||\", 1),\r\n    logicalAND: binop(\"&&\", 2),\r\n    bitwiseOR: binop(\"|\", 3),\r\n    bitwiseXOR: binop(\"^\", 4),\r\n    bitwiseAND: binop(\"&\", 5),\r\n    equality: binop(\"==/!=/===/!==\", 6),\r\n    relational: binop(\"</>/<=/>=\", 7),\r\n    bitShift: binop(\"<</>>/>>>\", 8),\r\n    plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\r\n    modulo: binop(\"%\", 10),\r\n    star: binop(\"*\", 10),\r\n    slash: binop(\"/\", 10),\r\n    starstar: new TokenType(\"**\", {beforeExpr: true}),\r\n\r\n    // Keyword token types.\r\n    _break: kw(\"break\"),\r\n    _case: kw(\"case\", beforeExpr),\r\n    _catch: kw(\"catch\"),\r\n    _continue: kw(\"continue\"),\r\n    _debugger: kw(\"debugger\"),\r\n    _default: kw(\"default\", beforeExpr),\r\n    _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\r\n    _else: kw(\"else\", beforeExpr),\r\n    _finally: kw(\"finally\"),\r\n    _for: kw(\"for\", {isLoop: true}),\r\n    _function: kw(\"function\", startsExpr),\r\n    _if: kw(\"if\"),\r\n    _return: kw(\"return\", beforeExpr),\r\n    _switch: kw(\"switch\"),\r\n    _throw: kw(\"throw\", beforeExpr),\r\n    _try: kw(\"try\"),\r\n    _var: kw(\"var\"),\r\n    _const: kw(\"const\"),\r\n    _while: kw(\"while\", {isLoop: true}),\r\n    _with: kw(\"with\"),\r\n    _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\r\n    _this: kw(\"this\", startsExpr),\r\n    _super: kw(\"super\", startsExpr),\r\n    _class: kw(\"class\", startsExpr),\r\n    _extends: kw(\"extends\", beforeExpr),\r\n    _export: kw(\"export\"),\r\n    _import: kw(\"import\"),\r\n    _null: kw(\"null\", startsExpr),\r\n    _true: kw(\"true\", startsExpr),\r\n    _false: kw(\"false\", startsExpr),\r\n    _in: kw(\"in\", {beforeExpr: true, binop: 7}),\r\n    _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\r\n    _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\r\n    _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\r\n    _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\r\n  };\r\n\r\n  // Matches a whole line break (where CRLF is considered a single\r\n  // line break). Used to count lines.\r\n\r\n  var lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\r\n  var lineBreakG = new RegExp(lineBreak.source, \"g\");\r\n\r\n  function isNewLine(code, ecma2019String) {\r\n    return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))\r\n  }\r\n\r\n  var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\r\n\r\n  var skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\r\n\r\n  var ref = Object.prototype;\r\n  var hasOwnProperty = ref.hasOwnProperty;\r\n  var toString = ref.toString;\r\n\r\n  // Checks if an object has a property.\r\n\r\n  function has(obj, propName) {\r\n    return hasOwnProperty.call(obj, propName)\r\n  }\r\n\r\n  var isArray = Array.isArray || (function (obj) { return (\r\n    toString.call(obj) === \"[object Array]\"\r\n  ); });\r\n\r\n  // These are used when `options.locations` is on, for the\r\n  // `startLoc` and `endLoc` properties.\r\n\r\n  var Position = function Position(line, col) {\r\n    this.line = line;\r\n    this.column = col;\r\n  };\r\n\r\n  Position.prototype.offset = function offset (n) {\r\n    return new Position(this.line, this.column + n)\r\n  };\r\n\r\n  var SourceLocation = function SourceLocation(p, start, end) {\r\n    this.start = start;\r\n    this.end = end;\r\n    if (p.sourceFile !== null) { this.source = p.sourceFile; }\r\n  };\r\n\r\n  // The `getLineInfo` function is mostly useful when the\r\n  // `locations` option is off (for performance reasons) and you\r\n  // want to find the line/column position for a given character\r\n  // offset. `input` should be the code string that the offset refers\r\n  // into.\r\n\r\n  function getLineInfo(input, offset) {\r\n    for (var line = 1, cur = 0;;) {\r\n      lineBreakG.lastIndex = cur;\r\n      var match = lineBreakG.exec(input);\r\n      if (match && match.index < offset) {\r\n        ++line;\r\n        cur = match.index + match[0].length;\r\n      } else {\r\n        return new Position(line, offset - cur)\r\n      }\r\n    }\r\n  }\r\n\r\n  // A second optional argument can be given to further configure\r\n  // the parser process. These options are recognized:\r\n\r\n  var defaultOptions = {\r\n    // `ecmaVersion` indicates the ECMAScript version to parse. Must\r\n    // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support\r\n    // for strict mode, the set of reserved words, and support for\r\n    // new syntax features. The default is 7.\r\n    ecmaVersion: 7,\r\n    // `sourceType` indicates the mode the code should be parsed in.\r\n    // Can be either `\"script\"` or `\"module\"`. This influences global\r\n    // strict mode and parsing of `import` and `export` declarations.\r\n    sourceType: \"script\",\r\n    // `onInsertedSemicolon` can be a callback that will be called\r\n    // when a semicolon is automatically inserted. It will be passed\r\n    // th position of the comma as an offset, and if `locations` is\r\n    // enabled, it is given the location as a `{line, column}` object\r\n    // as second argument.\r\n    onInsertedSemicolon: null,\r\n    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\r\n    // trailing commas.\r\n    onTrailingComma: null,\r\n    // By default, reserved words are only enforced if ecmaVersion >= 5.\r\n    // Set `allowReserved` to a boolean value to explicitly turn this on\r\n    // an off. When this option has the value \"never\", reserved words\r\n    // and keywords can also not be used as property names.\r\n    allowReserved: null,\r\n    // When enabled, a return at the top level is not considered an\r\n    // error.\r\n    allowReturnOutsideFunction: false,\r\n    // When enabled, import/export statements are not constrained to\r\n    // appearing at the top of the program.\r\n    allowImportExportEverywhere: false,\r\n    // When enabled, await identifiers are allowed to appear at the top-level scope,\r\n    // but they are still not allowed in non-async functions.\r\n    allowAwaitOutsideFunction: false,\r\n    // When enabled, hashbang directive in the beginning of file\r\n    // is allowed and treated as a line comment.\r\n    allowHashBang: false,\r\n    // When `locations` is on, `loc` properties holding objects with\r\n    // `start` and `end` properties in `{line, column}` form (with\r\n    // line being 1-based and column 0-based) will be attached to the\r\n    // nodes.\r\n    locations: false,\r\n    // A function can be passed as `onToken` option, which will\r\n    // cause Acorn to call that function with object in the same\r\n    // format as tokens returned from `tokenizer().getToken()`. Note\r\n    // that you are not allowed to call the parser from the\r\n    // callbackthat will corrupt its internal state.\r\n    onToken: null,\r\n    // A function can be passed as `onComment` option, which will\r\n    // cause Acorn to call that function with `(block, text, start,\r\n    // end)` parameters whenever a comment is skipped. `block` is a\r\n    // boolean indicating whether this is a block (`/* */`) comment,\r\n    // `text` is the content of the comment, and `start` and `end` are\r\n    // character offsets that denote the start and end of the comment.\r\n    // When the `locations` option is on, two more parameters are\r\n    // passed, the full `{line, column}` locations of the start and\r\n    // end of the comments. Note that you are not allowed to call the\r\n    // parser from the callbackthat will corrupt its internal state.\r\n    onComment: null,\r\n    // Nodes have their start and end characters offsets recorded in\r\n    // `start` and `end` properties (directly on the node, rather than\r\n    // the `loc` object, which holds line/column data. To also add a\r\n    // [semi-standardized][range] `range` property holding a `[start,\r\n    // end]` array with the same numbers, set the `ranges` option to\r\n    // `true`.\r\n    //\r\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\r\n    ranges: false,\r\n    // It is possible to parse multiple files into a single AST by\r\n    // passing the tree produced by parsing the first file as\r\n    // `program` option in subsequent parses. This will add the\r\n    // toplevel forms of the parsed file to the `Program` (top) node\r\n    // of an existing parse tree.\r\n    program: null,\r\n    // When `locations` is on, you can pass this to record the source\r\n    // file in every node's `loc` object.\r\n    sourceFile: null,\r\n    // This value, if given, is stored in every node, whether\r\n    // `locations` is on or off.\r\n    directSourceFile: null,\r\n    // When enabled, parenthesized expressions are represented by\r\n    // (non-standard) ParenthesizedExpression nodes\r\n    preserveParens: false,\r\n    plugins: {}\r\n  };\r\n\r\n  // Interpret and default an options object\r\n\r\n  function getOptions(opts) {\r\n    var options = {};\r\n\r\n    for (var opt in defaultOptions)\r\n      { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }\r\n\r\n    if (options.ecmaVersion >= 2015)\r\n      { options.ecmaVersion -= 2009; }\r\n\r\n    if (options.allowReserved == null)\r\n      { options.allowReserved = options.ecmaVersion < 5; }\r\n\r\n    if (isArray(options.onToken)) {\r\n      var tokens = options.onToken;\r\n      options.onToken = function (token) { return tokens.push(token); };\r\n    }\r\n    if (isArray(options.onComment))\r\n      { options.onComment = pushComment(options, options.onComment); }\r\n\r\n    return options\r\n  }\r\n\r\n  function pushComment(options, array) {\r\n    return function(block, text, start, end, startLoc, endLoc) {\r\n      var comment = {\r\n        type: block ? \"Block\" : \"Line\",\r\n        value: text,\r\n        start: start,\r\n        end: end\r\n      };\r\n      if (options.locations)\r\n        { comment.loc = new SourceLocation(this, startLoc, endLoc); }\r\n      if (options.ranges)\r\n        { comment.range = [start, end]; }\r\n      array.push(comment);\r\n    }\r\n  }\r\n\r\n  // Registered plugins\r\n  var plugins = {};\r\n\r\n  function keywordRegexp(words) {\r\n    return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\r\n  }\r\n\r\n  var Parser = function Parser(options, input, startPos) {\r\n    this.options = options = getOptions(options);\r\n    this.sourceFile = options.sourceFile;\r\n    this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);\r\n    var reserved = \"\";\r\n    if (!options.allowReserved) {\r\n      for (var v = options.ecmaVersion;; v--)\r\n        { if (reserved = reservedWords[v]) { break } }\r\n      if (options.sourceType === \"module\") { reserved += \" await\"; }\r\n    }\r\n    this.reservedWords = keywordRegexp(reserved);\r\n    var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\r\n    this.reservedWordsStrict = keywordRegexp(reservedStrict);\r\n    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind);\r\n    this.input = String(input);\r\n\r\n    // Used to signal to callers of `readWord1` whether the word\r\n    // contained any escape sequences. This is needed because words with\r\n    // escape sequences must not be interpreted as keywords.\r\n    this.containsEsc = false;\r\n\r\n    // Load plugins\r\n    this.loadPlugins(options.plugins);\r\n\r\n    // Set up token state\r\n\r\n    // The current position of the tokenizer in the input.\r\n    if (startPos) {\r\n      this.pos = startPos;\r\n      this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\r\n      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\r\n    } else {\r\n      this.pos = this.lineStart = 0;\r\n      this.curLine = 1;\r\n    }\r\n\r\n    // Properties of the current token:\r\n    // Its type\r\n    this.type = types.eof;\r\n    // For tokens that include more information than their type, the value\r\n    this.value = null;\r\n    // Its start and end offset\r\n    this.start = this.end = this.pos;\r\n    // And, if locations are used, the {line, column} object\r\n    // corresponding to those offsets\r\n    this.startLoc = this.endLoc = this.curPosition();\r\n\r\n    // Position information for the previous token\r\n    this.lastTokEndLoc = this.lastTokStartLoc = null;\r\n    this.lastTokStart = this.lastTokEnd = this.pos;\r\n\r\n    // The context stack is used to superficially track syntactic\r\n    // context to predict whether a regular expression is allowed in a\r\n    // given position.\r\n    this.context = this.initialContext();\r\n    this.exprAllowed = true;\r\n\r\n    // Figure out if it's a module code.\r\n    this.inModule = options.sourceType === \"module\";\r\n    this.strict = this.inModule || this.strictDirective(this.pos);\r\n\r\n    // Used to signify the start of a potential arrow function\r\n    this.potentialArrowAt = -1;\r\n\r\n    // Flags to track whether we are in a function, a generator, an async function.\r\n    this.inFunction = this.inGenerator = this.inAsync = false;\r\n    // Positions to delayed-check that yield/await does not exist in default parameters.\r\n    this.yieldPos = this.awaitPos = 0;\r\n    // Labels in scope.\r\n    this.labels = [];\r\n\r\n    // If enabled, skip leading hashbang line.\r\n    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\r\n      { this.skipLineComment(2); }\r\n\r\n    // Scope tracking for duplicate variable names (see scope.js)\r\n    this.scopeStack = [];\r\n    this.enterFunctionScope();\r\n\r\n    // For RegExp validation\r\n    this.regexpState = null;\r\n  };\r\n\r\n  // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\r\n  Parser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };\r\n  Parser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };\r\n\r\n  Parser.prototype.extend = function extend (name, f) {\r\n    this[name] = f(this[name]);\r\n  };\r\n\r\n  Parser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\r\n      var this$1 = this;\r\n\r\n    for (var name in pluginConfigs) {\r\n      var plugin = plugins[name];\r\n      if (!plugin) { throw new Error(\"Plugin '\" + name + \"' not found\") }\r\n      plugin(this$1, pluginConfigs[name]);\r\n    }\r\n  };\r\n\r\n  Parser.prototype.parse = function parse () {\r\n    var node = this.options.program || this.startNode();\r\n    this.nextToken();\r\n    return this.parseTopLevel(node)\r\n  };\r\n\r\n  var pp = Parser.prototype;\r\n\r\n  // ## Parser utilities\r\n\r\n  var literal = /^(?:'((?:\\\\.|[^'])*?)'|\"((?:\\\\.|[^\"])*?)\"|;)/;\r\n  pp.strictDirective = function(start) {\r\n    var this$1 = this;\r\n\r\n    for (;;) {\r\n      skipWhiteSpace.lastIndex = start;\r\n      start += skipWhiteSpace.exec(this$1.input)[0].length;\r\n      var match = literal.exec(this$1.input.slice(start));\r\n      if (!match) { return false }\r\n      if ((match[1] || match[2]) === \"use strict\") { return true }\r\n      start += match[0].length;\r\n    }\r\n  };\r\n\r\n  // Predicate that tests whether the next token is of the given\r\n  // type, and if yes, consumes it as a side effect.\r\n\r\n  pp.eat = function(type) {\r\n    if (this.type === type) {\r\n      this.next();\r\n      return true\r\n    } else {\r\n      return false\r\n    }\r\n  };\r\n\r\n  // Tests whether parsed token is a contextual keyword.\r\n\r\n  pp.isContextual = function(name) {\r\n    return this.type === types.name && this.value === name && !this.containsEsc\r\n  };\r\n\r\n  // Consumes contextual keyword if possible.\r\n\r\n  pp.eatContextual = function(name) {\r\n    if (!this.isContextual(name)) { return false }\r\n    this.next();\r\n    return true\r\n  };\r\n\r\n  // Asserts that following token is given contextual keyword.\r\n\r\n  pp.expectContextual = function(name) {\r\n    if (!this.eatContextual(name)) { this.unexpected(); }\r\n  };\r\n\r\n  // Test whether a semicolon can be inserted at the current position.\r\n\r\n  pp.canInsertSemicolon = function() {\r\n    return this.type === types.eof ||\r\n      this.type === types.braceR ||\r\n      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\r\n  };\r\n\r\n  pp.insertSemicolon = function() {\r\n    if (this.canInsertSemicolon()) {\r\n      if (this.options.onInsertedSemicolon)\r\n        { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\r\n      return true\r\n    }\r\n  };\r\n\r\n  // Consume a semicolon, or, failing that, see if we are allowed to\r\n  // pretend that there is a semicolon at this position.\r\n\r\n  pp.semicolon = function() {\r\n    if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }\r\n  };\r\n\r\n  pp.afterTrailingComma = function(tokType, notNext) {\r\n    if (this.type === tokType) {\r\n      if (this.options.onTrailingComma)\r\n        { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\r\n      if (!notNext)\r\n        { this.next(); }\r\n      return true\r\n    }\r\n  };\r\n\r\n  // Expect a token of a given type. If found, consume it, otherwise,\r\n  // raise an unexpected token error.\r\n\r\n  pp.expect = function(type) {\r\n    this.eat(type) || this.unexpected();\r\n  };\r\n\r\n  // Raise an unexpected token error.\r\n\r\n  pp.unexpected = function(pos) {\r\n    this.raise(pos != null ? pos : this.start, \"Unexpected token\");\r\n  };\r\n\r\n  function DestructuringErrors() {\r\n    this.shorthandAssign =\r\n    this.trailingComma =\r\n    this.parenthesizedAssign =\r\n    this.parenthesizedBind =\r\n    this.doubleProto =\r\n      -1;\r\n  }\r\n\r\n  pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\r\n    if (!refDestructuringErrors) { return }\r\n    if (refDestructuringErrors.trailingComma > -1)\r\n      { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\r\n    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\r\n    if (parens > -1) { this.raiseRecoverable(parens, \"Parenthesized pattern\"); }\r\n  };\r\n\r\n  pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\r\n    if (!refDestructuringErrors) { return false }\r\n    var shorthandAssign = refDestructuringErrors.shorthandAssign;\r\n    var doubleProto = refDestructuringErrors.doubleProto;\r\n    if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\r\n    if (shorthandAssign >= 0)\r\n      { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\r\n    if (doubleProto >= 0)\r\n      { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\r\n  };\r\n\r\n  pp.checkYieldAwaitInDefaultParams = function() {\r\n    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\r\n      { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\r\n    if (this.awaitPos)\r\n      { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\r\n  };\r\n\r\n  pp.isSimpleAssignTarget = function(expr) {\r\n    if (expr.type === \"ParenthesizedExpression\")\r\n      { return this.isSimpleAssignTarget(expr.expression) }\r\n    return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\r\n  };\r\n\r\n  var pp$1 = Parser.prototype;\r\n\r\n  // ### Statement parsing\r\n\r\n  // Parse a program. Initializes the parser, reads any number of\r\n  // statements, and wraps them in a Program node.  Optionally takes a\r\n  // `program` argument.  If present, the statements will be appended\r\n  // to its body instead of creating a new node.\r\n\r\n  pp$1.parseTopLevel = function(node) {\r\n    var this$1 = this;\r\n\r\n    var exports = {};\r\n    if (!node.body) { node.body = []; }\r\n    while (this.type !== types.eof) {\r\n      var stmt = this$1.parseStatement(true, true, exports);\r\n      node.body.push(stmt);\r\n    }\r\n    this.adaptDirectivePrologue(node.body);\r\n    this.next();\r\n    if (this.options.ecmaVersion >= 6) {\r\n      node.sourceType = this.options.sourceType;\r\n    }\r\n    return this.finishNode(node, \"Program\")\r\n  };\r\n\r\n  var loopLabel = {kind: \"loop\"};\r\n  var switchLabel = {kind: \"switch\"};\r\n\r\n  pp$1.isLet = function() {\r\n    if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\r\n    skipWhiteSpace.lastIndex = this.pos;\r\n    var skip = skipWhiteSpace.exec(this.input);\r\n    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\r\n    if (nextCh === 91 || nextCh === 123) { return true } // '{' and '['\r\n    if (isIdentifierStart(nextCh, true)) {\r\n      var pos = next + 1;\r\n      while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\r\n      var ident = this.input.slice(next, pos);\r\n      if (!keywordRelationalOperator.test(ident)) { return true }\r\n    }\r\n    return false\r\n  };\r\n\r\n  // check 'async [no LineTerminator here] function'\r\n  // - 'async /*foo*/ function' is OK.\r\n  // - 'async /*\\n*/ function' is invalid.\r\n  pp$1.isAsyncFunction = function() {\r\n    if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\r\n      { return false }\r\n\r\n    skipWhiteSpace.lastIndex = this.pos;\r\n    var skip = skipWhiteSpace.exec(this.input);\r\n    var next = this.pos + skip[0].length;\r\n    return !lineBreak.test(this.input.slice(this.pos, next)) &&\r\n      this.input.slice(next, next + 8) === \"function\" &&\r\n      (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\r\n  };\r\n\r\n  // Parse a single statement.\r\n  //\r\n  // If expecting a statement and finding a slash operator, parse a\r\n  // regular expression literal. This is to handle cases like\r\n  // `if (foo) /blah/.exec(foo)`, where looking at the previous token\r\n  // does not help.\r\n\r\n  pp$1.parseStatement = function(declaration, topLevel, exports) {\r\n    var starttype = this.type, node = this.startNode(), kind;\r\n\r\n    if (this.isLet()) {\r\n      starttype = types._var;\r\n      kind = \"let\";\r\n    }\r\n\r\n    // Most types of statements are recognized by the keyword they\r\n    // start with. Many are trivial to parse, some require a bit of\r\n    // complexity.\r\n\r\n    switch (starttype) {\r\n    case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\r\n    case types._debugger: return this.parseDebuggerStatement(node)\r\n    case types._do: return this.parseDoStatement(node)\r\n    case types._for: return this.parseForStatement(node)\r\n    case types._function:\r\n      if (!declaration && this.options.ecmaVersion >= 6) { this.unexpected(); }\r\n      return this.parseFunctionStatement(node, false)\r\n    case types._class:\r\n      if (!declaration) { this.unexpected(); }\r\n      return this.parseClass(node, true)\r\n    case types._if: return this.parseIfStatement(node)\r\n    case types._return: return this.parseReturnStatement(node)\r\n    case types._switch: return this.parseSwitchStatement(node)\r\n    case types._throw: return this.parseThrowStatement(node)\r\n    case types._try: return this.parseTryStatement(node)\r\n    case types._const: case types._var:\r\n      kind = kind || this.value;\r\n      if (!declaration && kind !== \"var\") { this.unexpected(); }\r\n      return this.parseVarStatement(node, kind)\r\n    case types._while: return this.parseWhileStatement(node)\r\n    case types._with: return this.parseWithStatement(node)\r\n    case types.braceL: return this.parseBlock()\r\n    case types.semi: return this.parseEmptyStatement(node)\r\n    case types._export:\r\n    case types._import:\r\n      if (!this.options.allowImportExportEverywhere) {\r\n        if (!topLevel)\r\n          { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\r\n        if (!this.inModule)\r\n          { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\r\n      }\r\n      return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)\r\n\r\n      // If the statement does not start with a statement keyword or a\r\n      // brace, it's an ExpressionStatement or LabeledStatement. We\r\n      // simply start parsing an expression, and afterwards, if the\r\n      // next token is a colon and the expression was a simple\r\n      // Identifier node, we switch to interpreting it as a label.\r\n    default:\r\n      if (this.isAsyncFunction()) {\r\n        if (!declaration) { this.unexpected(); }\r\n        this.next();\r\n        return this.parseFunctionStatement(node, true)\r\n      }\r\n\r\n      var maybeName = this.value, expr = this.parseExpression();\r\n      if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\r\n        { return this.parseLabeledStatement(node, maybeName, expr) }\r\n      else { return this.parseExpressionStatement(node, expr) }\r\n    }\r\n  };\r\n\r\n  pp$1.parseBreakContinueStatement = function(node, keyword) {\r\n    var this$1 = this;\r\n\r\n    var isBreak = keyword === \"break\";\r\n    this.next();\r\n    if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }\r\n    else if (this.type !== types.name) { this.unexpected(); }\r\n    else {\r\n      node.label = this.parseIdent();\r\n      this.semicolon();\r\n    }\r\n\r\n    // Verify that there is an actual destination to break or\r\n    // continue to.\r\n    var i = 0;\r\n    for (; i < this.labels.length; ++i) {\r\n      var lab = this$1.labels[i];\r\n      if (node.label == null || lab.name === node.label.name) {\r\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\r\n        if (node.label && isBreak) { break }\r\n      }\r\n    }\r\n    if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\r\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\r\n  };\r\n\r\n  pp$1.parseDebuggerStatement = function(node) {\r\n    this.next();\r\n    this.semicolon();\r\n    return this.finishNode(node, \"DebuggerStatement\")\r\n  };\r\n\r\n  pp$1.parseDoStatement = function(node) {\r\n    this.next();\r\n    this.labels.push(loopLabel);\r\n    node.body = this.parseStatement(false);\r\n    this.labels.pop();\r\n    this.expect(types._while);\r\n    node.test = this.parseParenExpression();\r\n    if (this.options.ecmaVersion >= 6)\r\n      { this.eat(types.semi); }\r\n    else\r\n      { this.semicolon(); }\r\n    return this.finishNode(node, \"DoWhileStatement\")\r\n  };\r\n\r\n  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\r\n  // loop is non-trivial. Basically, we have to parse the init `var`\r\n  // statement or expression, disallowing the `in` operator (see\r\n  // the second parameter to `parseExpression`), and then check\r\n  // whether the next token is `in` or `of`. When there is no init\r\n  // part (semicolon immediately after the opening parenthesis), it\r\n  // is a regular `for` loop.\r\n\r\n  pp$1.parseForStatement = function(node) {\r\n    this.next();\r\n    var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\r\n    this.labels.push(loopLabel);\r\n    this.enterLexicalScope();\r\n    this.expect(types.parenL);\r\n    if (this.type === types.semi) {\r\n      if (awaitAt > -1) { this.unexpected(awaitAt); }\r\n      return this.parseFor(node, null)\r\n    }\r\n    var isLet = this.isLet();\r\n    if (this.type === types._var || this.type === types._const || isLet) {\r\n      var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\r\n      this.next();\r\n      this.parseVar(init$1, true, kind);\r\n      this.finishNode(init$1, \"VariableDeclaration\");\r\n      if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1 &&\r\n          !(kind !== \"var\" && init$1.declarations[0].init)) {\r\n        if (this.options.ecmaVersion >= 9) {\r\n          if (this.type === types._in) {\r\n            if (awaitAt > -1) { this.unexpected(awaitAt); }\r\n          } else { node.await = awaitAt > -1; }\r\n        }\r\n        return this.parseForIn(node, init$1)\r\n      }\r\n      if (awaitAt > -1) { this.unexpected(awaitAt); }\r\n      return this.parseFor(node, init$1)\r\n    }\r\n    var refDestructuringErrors = new DestructuringErrors;\r\n    var init = this.parseExpression(true, refDestructuringErrors);\r\n    if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\r\n      if (this.options.ecmaVersion >= 9) {\r\n        if (this.type === types._in) {\r\n          if (awaitAt > -1) { this.unexpected(awaitAt); }\r\n        } else { node.await = awaitAt > -1; }\r\n      }\r\n      this.toAssignable(init, false, refDestructuringErrors);\r\n      this.checkLVal(init);\r\n      return this.parseForIn(node, init)\r\n    } else {\r\n      this.checkExpressionErrors(refDestructuringErrors, true);\r\n    }\r\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\r\n    return this.parseFor(node, init)\r\n  };\r\n\r\n  pp$1.parseFunctionStatement = function(node, isAsync) {\r\n    this.next();\r\n    return this.parseFunction(node, true, false, isAsync)\r\n  };\r\n\r\n  pp$1.parseIfStatement = function(node) {\r\n    this.next();\r\n    node.test = this.parseParenExpression();\r\n    // allow function declarations in branches, but only in non-strict mode\r\n    node.consequent = this.parseStatement(!this.strict && this.type === types._function);\r\n    node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.type === types._function) : null;\r\n    return this.finishNode(node, \"IfStatement\")\r\n  };\r\n\r\n  pp$1.parseReturnStatement = function(node) {\r\n    if (!this.inFunction && !this.options.allowReturnOutsideFunction)\r\n      { this.raise(this.start, \"'return' outside of function\"); }\r\n    this.next();\r\n\r\n    // In `return` (and `break`/`continue`), the keywords with\r\n    // optional arguments, we eagerly look for a semicolon or the\r\n    // possibility to insert one.\r\n\r\n    if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }\r\n    else { node.argument = this.parseExpression(); this.semicolon(); }\r\n    return this.finishNode(node, \"ReturnStatement\")\r\n  };\r\n\r\n  pp$1.parseSwitchStatement = function(node) {\r\n    var this$1 = this;\r\n\r\n    this.next();\r\n    node.discriminant = this.parseParenExpression();\r\n    node.cases = [];\r\n    this.expect(types.braceL);\r\n    this.labels.push(switchLabel);\r\n    this.enterLexicalScope();\r\n\r\n    // Statements under must be grouped (by label) in SwitchCase\r\n    // nodes. `cur` is used to keep the node that we are currently\r\n    // adding statements to.\r\n\r\n    var cur;\r\n    for (var sawDefault = false; this.type !== types.braceR;) {\r\n      if (this$1.type === types._case || this$1.type === types._default) {\r\n        var isCase = this$1.type === types._case;\r\n        if (cur) { this$1.finishNode(cur, \"SwitchCase\"); }\r\n        node.cases.push(cur = this$1.startNode());\r\n        cur.consequent = [];\r\n        this$1.next();\r\n        if (isCase) {\r\n          cur.test = this$1.parseExpression();\r\n        } else {\r\n          if (sawDefault) { this$1.raiseRecoverable(this$1.lastTokStart, \"Multiple default clauses\"); }\r\n          sawDefault = true;\r\n          cur.test = null;\r\n        }\r\n        this$1.expect(types.colon);\r\n      } else {\r\n        if (!cur) { this$1.unexpected(); }\r\n        cur.consequent.push(this$1.parseStatement(true));\r\n      }\r\n    }\r\n    this.exitLexicalScope();\r\n    if (cur) { this.finishNode(cur, \"SwitchCase\"); }\r\n    this.next(); // Closing brace\r\n    this.labels.pop();\r\n    return this.finishNode(node, \"SwitchStatement\")\r\n  };\r\n\r\n  pp$1.parseThrowStatement = function(node) {\r\n    this.next();\r\n    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\r\n      { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\r\n    node.argument = this.parseExpression();\r\n    this.semicolon();\r\n    return this.finishNode(node, \"ThrowStatement\")\r\n  };\r\n\r\n  // Reused empty array added for node fields that are always empty.\r\n\r\n  var empty = [];\r\n\r\n  pp$1.parseTryStatement = function(node) {\r\n    this.next();\r\n    node.block = this.parseBlock();\r\n    node.handler = null;\r\n    if (this.type === types._catch) {\r\n      var clause = this.startNode();\r\n      this.next();\r\n      if (this.eat(types.parenL)) {\r\n        clause.param = this.parseBindingAtom();\r\n        this.enterLexicalScope();\r\n        this.checkLVal(clause.param, \"let\");\r\n        this.expect(types.parenR);\r\n      } else {\r\n        if (this.options.ecmaVersion < 10) { this.unexpected(); }\r\n        clause.param = null;\r\n        this.enterLexicalScope();\r\n      }\r\n      clause.body = this.parseBlock(false);\r\n      this.exitLexicalScope();\r\n      node.handler = this.finishNode(clause, \"CatchClause\");\r\n    }\r\n    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\r\n    if (!node.handler && !node.finalizer)\r\n      { this.raise(node.start, \"Missing catch or finally clause\"); }\r\n    return this.finishNode(node, \"TryStatement\")\r\n  };\r\n\r\n  pp$1.parseVarStatement = function(node, kind) {\r\n    this.next();\r\n    this.parseVar(node, false, kind);\r\n    this.semicolon();\r\n    return this.finishNode(node, \"VariableDeclaration\")\r\n  };\r\n\r\n  pp$1.parseWhileStatement = function(node) {\r\n    this.next();\r\n    node.test = this.parseParenExpression();\r\n    this.labels.push(loopLabel);\r\n    node.body = this.parseStatement(false);\r\n    this.labels.pop();\r\n    return this.finishNode(node, \"WhileStatement\")\r\n  };\r\n\r\n  pp$1.parseWithStatement = function(node) {\r\n    if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\r\n    this.next();\r\n    node.object = this.parseParenExpression();\r\n    node.body = this.parseStatement(false);\r\n    return this.finishNode(node, \"WithStatement\")\r\n  };\r\n\r\n  pp$1.parseEmptyStatement = function(node) {\r\n    this.next();\r\n    return this.finishNode(node, \"EmptyStatement\")\r\n  };\r\n\r\n  pp$1.parseLabeledStatement = function(node, maybeName, expr) {\r\n    var this$1 = this;\r\n\r\n    for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1)\r\n      {\r\n      var label = list[i$1];\r\n\r\n      if (label.name === maybeName)\r\n        { this$1.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\r\n    } }\r\n    var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\r\n    for (var i = this.labels.length - 1; i >= 0; i--) {\r\n      var label$1 = this$1.labels[i];\r\n      if (label$1.statementStart === node.start) {\r\n        // Update information about previous labels on this node\r\n        label$1.statementStart = this$1.start;\r\n        label$1.kind = kind;\r\n      } else { break }\r\n    }\r\n    this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\r\n    node.body = this.parseStatement(true);\r\n    if (node.body.type === \"ClassDeclaration\" ||\r\n        node.body.type === \"VariableDeclaration\" && node.body.kind !== \"var\" ||\r\n        node.body.type === \"FunctionDeclaration\" && (this.strict || node.body.generator || node.body.async))\r\n      { this.raiseRecoverable(node.body.start, \"Invalid labeled declaration\"); }\r\n    this.labels.pop();\r\n    node.label = expr;\r\n    return this.finishNode(node, \"LabeledStatement\")\r\n  };\r\n\r\n  pp$1.parseExpressionStatement = function(node, expr) {\r\n    node.expression = expr;\r\n    this.semicolon();\r\n    return this.finishNode(node, \"ExpressionStatement\")\r\n  };\r\n\r\n  // Parse a semicolon-enclosed block of statements, handling `\"use\r\n  // strict\"` declarations when `allowStrict` is true (used for\r\n  // function bodies).\r\n\r\n  pp$1.parseBlock = function(createNewLexicalScope) {\r\n    var this$1 = this;\r\n    if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\r\n\r\n    var node = this.startNode();\r\n    node.body = [];\r\n    this.expect(types.braceL);\r\n    if (createNewLexicalScope) {\r\n      this.enterLexicalScope();\r\n    }\r\n    while (!this.eat(types.braceR)) {\r\n      var stmt = this$1.parseStatement(true);\r\n      node.body.push(stmt);\r\n    }\r\n    if (createNewLexicalScope) {\r\n      this.exitLexicalScope();\r\n    }\r\n    return this.finishNode(node, \"BlockStatement\")\r\n  };\r\n\r\n  // Parse a regular `for` loop. The disambiguation code in\r\n  // `parseStatement` will already have parsed the init statement or\r\n  // expression.\r\n\r\n  pp$1.parseFor = function(node, init) {\r\n    node.init = init;\r\n    this.expect(types.semi);\r\n    node.test = this.type === types.semi ? null : this.parseExpression();\r\n    this.expect(types.semi);\r\n    node.update = this.type === types.parenR ? null : this.parseExpression();\r\n    this.expect(types.parenR);\r\n    this.exitLexicalScope();\r\n    node.body = this.parseStatement(false);\r\n    this.labels.pop();\r\n    return this.finishNode(node, \"ForStatement\")\r\n  };\r\n\r\n  // Parse a `for`/`in` and `for`/`of` loop, which are almost\r\n  // same from parser's perspective.\r\n\r\n  pp$1.parseForIn = function(node, init) {\r\n    var type = this.type === types._in ? \"ForInStatement\" : \"ForOfStatement\";\r\n    this.next();\r\n    if (type === \"ForInStatement\") {\r\n      if (init.type === \"AssignmentPattern\" ||\r\n        (init.type === \"VariableDeclaration\" && init.declarations[0].init != null &&\r\n         (this.strict || init.declarations[0].id.type !== \"Identifier\")))\r\n        { this.raise(init.start, \"Invalid assignment in for-in loop head\"); }\r\n    }\r\n    node.left = init;\r\n    node.right = type === \"ForInStatement\" ? this.parseExpression() : this.parseMaybeAssign();\r\n    this.expect(types.parenR);\r\n    this.exitLexicalScope();\r\n    node.body = this.parseStatement(false);\r\n    this.labels.pop();\r\n    return this.finishNode(node, type)\r\n  };\r\n\r\n  // Parse a list of variable declarations.\r\n\r\n  pp$1.parseVar = function(node, isFor, kind) {\r\n    var this$1 = this;\r\n\r\n    node.declarations = [];\r\n    node.kind = kind;\r\n    for (;;) {\r\n      var decl = this$1.startNode();\r\n      this$1.parseVarId(decl, kind);\r\n      if (this$1.eat(types.eq)) {\r\n        decl.init = this$1.parseMaybeAssign(isFor);\r\n      } else if (kind === \"const\" && !(this$1.type === types._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual(\"of\")))) {\r\n        this$1.unexpected();\r\n      } else if (decl.id.type !== \"Identifier\" && !(isFor && (this$1.type === types._in || this$1.isContextual(\"of\")))) {\r\n        this$1.raise(this$1.lastTokEnd, \"Complex binding patterns require an initialization value\");\r\n      } else {\r\n        decl.init = null;\r\n      }\r\n      node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"));\r\n      if (!this$1.eat(types.comma)) { break }\r\n    }\r\n    return node\r\n  };\r\n\r\n  pp$1.parseVarId = function(decl, kind) {\r\n    decl.id = this.parseBindingAtom(kind);\r\n    this.checkLVal(decl.id, kind, false);\r\n  };\r\n\r\n  // Parse a function declaration or literal (depending on the\r\n  // `isStatement` parameter).\r\n\r\n  pp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {\r\n    this.initFunction(node);\r\n    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync)\r\n      { node.generator = this.eat(types.star); }\r\n    if (this.options.ecmaVersion >= 8)\r\n      { node.async = !!isAsync; }\r\n\r\n    if (isStatement) {\r\n      node.id = isStatement === \"nullableID\" && this.type !== types.name ? null : this.parseIdent();\r\n      if (node.id) {\r\n        this.checkLVal(node.id, this.inModule && !this.inFunction ? \"let\" : \"var\");\r\n      }\r\n    }\r\n\r\n    var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\r\n        oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\r\n    this.inGenerator = node.generator;\r\n    this.inAsync = node.async;\r\n    this.yieldPos = 0;\r\n    this.awaitPos = 0;\r\n    this.inFunction = true;\r\n    this.enterFunctionScope();\r\n\r\n    if (!isStatement)\r\n      { node.id = this.type === types.name ? this.parseIdent() : null; }\r\n\r\n    this.parseFunctionParams(node);\r\n    this.parseFunctionBody(node, allowExpressionBody);\r\n\r\n    this.inGenerator = oldInGen;\r\n    this.inAsync = oldInAsync;\r\n    this.yieldPos = oldYieldPos;\r\n    this.awaitPos = oldAwaitPos;\r\n    this.inFunction = oldInFunc;\r\n    return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\r\n  };\r\n\r\n  pp$1.parseFunctionParams = function(node) {\r\n    this.expect(types.parenL);\r\n    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\r\n    this.checkYieldAwaitInDefaultParams();\r\n  };\r\n\r\n  // Parse a class declaration or literal (depending on the\r\n  // `isStatement` parameter).\r\n\r\n  pp$1.parseClass = function(node, isStatement) {\r\n    var this$1 = this;\r\n\r\n    this.next();\r\n\r\n    this.parseClassId(node, isStatement);\r\n    this.parseClassSuper(node);\r\n    var classBody = this.startNode();\r\n    var hadConstructor = false;\r\n    classBody.body = [];\r\n    this.expect(types.braceL);\r\n    while (!this.eat(types.braceR)) {\r\n      var member = this$1.parseClassMember(classBody);\r\n      if (member && member.type === \"MethodDefinition\" && member.kind === \"constructor\") {\r\n        if (hadConstructor) { this$1.raise(member.start, \"Duplicate constructor in the same class\"); }\r\n        hadConstructor = true;\r\n      }\r\n    }\r\n    node.body = this.finishNode(classBody, \"ClassBody\");\r\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\r\n  };\r\n\r\n  pp$1.parseClassMember = function(classBody) {\r\n    var this$1 = this;\r\n\r\n    if (this.eat(types.semi)) { return null }\r\n\r\n    var method = this.startNode();\r\n    var tryContextual = function (k, noLineBreak) {\r\n      if ( noLineBreak === void 0 ) noLineBreak = false;\r\n\r\n      var start = this$1.start, startLoc = this$1.startLoc;\r\n      if (!this$1.eatContextual(k)) { return false }\r\n      if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }\r\n      if (method.key) { this$1.unexpected(); }\r\n      method.computed = false;\r\n      method.key = this$1.startNodeAt(start, startLoc);\r\n      method.key.name = k;\r\n      this$1.finishNode(method.key, \"Identifier\");\r\n      return false\r\n    };\r\n\r\n    method.kind = \"method\";\r\n    method.static = tryContextual(\"static\");\r\n    var isGenerator = this.eat(types.star);\r\n    var isAsync = false;\r\n    if (!isGenerator) {\r\n      if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\r\n        isAsync = true;\r\n        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\r\n      } else if (tryContextual(\"get\")) {\r\n        method.kind = \"get\";\r\n      } else if (tryContextual(\"set\")) {\r\n        method.kind = \"set\";\r\n      }\r\n    }\r\n    if (!method.key) { this.parsePropertyName(method); }\r\n    var key = method.key;\r\n    if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\r\n        key.type === \"Literal\" && key.value === \"constructor\")) {\r\n      if (method.kind !== \"method\") { this.raise(key.start, \"Constructor can't have get/set modifier\"); }\r\n      if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\r\n      if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\r\n      method.kind = \"constructor\";\r\n    } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\r\n      this.raise(key.start, \"Classes may not have a static property named prototype\");\r\n    }\r\n    this.parseClassMethod(classBody, method, isGenerator, isAsync);\r\n    if (method.kind === \"get\" && method.value.params.length !== 0)\r\n      { this.raiseRecoverable(method.value.start, \"getter should have no params\"); }\r\n    if (method.kind === \"set\" && method.value.params.length !== 1)\r\n      { this.raiseRecoverable(method.value.start, \"setter should have exactly one param\"); }\r\n    if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\r\n      { this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\"); }\r\n    return method\r\n  };\r\n\r\n  pp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {\r\n    method.value = this.parseMethod(isGenerator, isAsync);\r\n    classBody.body.push(this.finishNode(method, \"MethodDefinition\"));\r\n  };\r\n\r\n  pp$1.parseClassId = function(node, isStatement) {\r\n    node.id = this.type === types.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null;\r\n  };\r\n\r\n  pp$1.parseClassSuper = function(node) {\r\n    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\r\n  };\r\n\r\n  // Parses module export declaration.\r\n\r\n  pp$1.parseExport = function(node, exports) {\r\n    var this$1 = this;\r\n\r\n    this.next();\r\n    // export * from '...'\r\n    if (this.eat(types.star)) {\r\n      this.expectContextual(\"from\");\r\n      if (this.type !== types.string) { this.unexpected(); }\r\n      node.source = this.parseExprAtom();\r\n      this.semicolon();\r\n      return this.finishNode(node, \"ExportAllDeclaration\")\r\n    }\r\n    if (this.eat(types._default)) { // export default ...\r\n      this.checkExport(exports, \"default\", this.lastTokStart);\r\n      var isAsync;\r\n      if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\r\n        var fNode = this.startNode();\r\n        this.next();\r\n        if (isAsync) { this.next(); }\r\n        node.declaration = this.parseFunction(fNode, \"nullableID\", false, isAsync);\r\n      } else if (this.type === types._class) {\r\n        var cNode = this.startNode();\r\n        node.declaration = this.parseClass(cNode, \"nullableID\");\r\n      } else {\r\n        node.declaration = this.parseMaybeAssign();\r\n        this.semicolon();\r\n      }\r\n      return this.finishNode(node, \"ExportDefaultDeclaration\")\r\n    }\r\n    // export var|const|let|function|class ...\r\n    if (this.shouldParseExportStatement()) {\r\n      node.declaration = this.parseStatement(true);\r\n      if (node.declaration.type === \"VariableDeclaration\")\r\n        { this.checkVariableExport(exports, node.declaration.declarations); }\r\n      else\r\n        { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\r\n      node.specifiers = [];\r\n      node.source = null;\r\n    } else { // export { x, y as z } [from '...']\r\n      node.declaration = null;\r\n      node.specifiers = this.parseExportSpecifiers(exports);\r\n      if (this.eatContextual(\"from\")) {\r\n        if (this.type !== types.string) { this.unexpected(); }\r\n        node.source = this.parseExprAtom();\r\n      } else {\r\n        // check for keywords used as local names\r\n        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\r\n          var spec = list[i];\r\n\r\n          this$1.checkUnreserved(spec.local);\r\n        }\r\n\r\n        node.source = null;\r\n      }\r\n      this.semicolon();\r\n    }\r\n    return this.finishNode(node, \"ExportNamedDeclaration\")\r\n  };\r\n\r\n  pp$1.checkExport = function(exports, name, pos) {\r\n    if (!exports) { return }\r\n    if (has(exports, name))\r\n      { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\r\n    exports[name] = true;\r\n  };\r\n\r\n  pp$1.checkPatternExport = function(exports, pat) {\r\n    var this$1 = this;\r\n\r\n    var type = pat.type;\r\n    if (type === \"Identifier\")\r\n      { this.checkExport(exports, pat.name, pat.start); }\r\n    else if (type === \"ObjectPattern\")\r\n      { for (var i = 0, list = pat.properties; i < list.length; i += 1)\r\n        {\r\n          var prop = list[i];\r\n\r\n          this$1.checkPatternExport(exports, prop);\r\n        } }\r\n    else if (type === \"ArrayPattern\")\r\n      { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\r\n        var elt = list$1[i$1];\r\n\r\n          if (elt) { this$1.checkPatternExport(exports, elt); }\r\n      } }\r\n    else if (type === \"Property\")\r\n      { this.checkPatternExport(exports, pat.value); }\r\n    else if (type === \"AssignmentPattern\")\r\n      { this.checkPatternExport(exports, pat.left); }\r\n    else if (type === \"RestElement\")\r\n      { this.checkPatternExport(exports, pat.argument); }\r\n    else if (type === \"ParenthesizedExpression\")\r\n      { this.checkPatternExport(exports, pat.expression); }\r\n  };\r\n\r\n  pp$1.checkVariableExport = function(exports, decls) {\r\n    var this$1 = this;\r\n\r\n    if (!exports) { return }\r\n    for (var i = 0, list = decls; i < list.length; i += 1)\r\n      {\r\n      var decl = list[i];\r\n\r\n      this$1.checkPatternExport(exports, decl.id);\r\n    }\r\n  };\r\n\r\n  pp$1.shouldParseExportStatement = function() {\r\n    return this.type.keyword === \"var\" ||\r\n      this.type.keyword === \"const\" ||\r\n      this.type.keyword === \"class\" ||\r\n      this.type.keyword === \"function\" ||\r\n      this.isLet() ||\r\n      this.isAsyncFunction()\r\n  };\r\n\r\n  // Parses a comma-separated list of module exports.\r\n\r\n  pp$1.parseExportSpecifiers = function(exports) {\r\n    var this$1 = this;\r\n\r\n    var nodes = [], first = true;\r\n    // export { x, y as z } [from '...']\r\n    this.expect(types.braceL);\r\n    while (!this.eat(types.braceR)) {\r\n      if (!first) {\r\n        this$1.expect(types.comma);\r\n        if (this$1.afterTrailingComma(types.braceR)) { break }\r\n      } else { first = false; }\r\n\r\n      var node = this$1.startNode();\r\n      node.local = this$1.parseIdent(true);\r\n      node.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent(true) : node.local;\r\n      this$1.checkExport(exports, node.exported.name, node.exported.start);\r\n      nodes.push(this$1.finishNode(node, \"ExportSpecifier\"));\r\n    }\r\n    return nodes\r\n  };\r\n\r\n  // Parses import declaration.\r\n\r\n  pp$1.parseImport = function(node) {\r\n    this.next();\r\n    // import '...'\r\n    if (this.type === types.string) {\r\n      node.specifiers = empty;\r\n      node.source = this.parseExprAtom();\r\n    } else {\r\n      node.specifiers = this.parseImportSpecifiers();\r\n      this.expectContextual(\"from\");\r\n      node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\r\n    }\r\n    this.semicolon();\r\n    return this.finishNode(node, \"ImportDeclaration\")\r\n  };\r\n\r\n  // Parses a comma-separated list of module imports.\r\n\r\n  pp$1.parseImportSpecifiers = function() {\r\n    var this$1 = this;\r\n\r\n    var nodes = [], first = true;\r\n    if (this.type === types.name) {\r\n      // import defaultObj, { x, y as z } from '...'\r\n      var node = this.startNode();\r\n      node.local = this.parseIdent();\r\n      this.checkLVal(node.local, \"let\");\r\n      nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\r\n      if (!this.eat(types.comma)) { return nodes }\r\n    }\r\n    if (this.type === types.star) {\r\n      var node$1 = this.startNode();\r\n      this.next();\r\n      this.expectContextual(\"as\");\r\n      node$1.local = this.parseIdent();\r\n      this.checkLVal(node$1.local, \"let\");\r\n      nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\r\n      return nodes\r\n    }\r\n    this.expect(types.braceL);\r\n    while (!this.eat(types.braceR)) {\r\n      if (!first) {\r\n        this$1.expect(types.comma);\r\n        if (this$1.afterTrailingComma(types.braceR)) { break }\r\n      } else { first = false; }\r\n\r\n      var node$2 = this$1.startNode();\r\n      node$2.imported = this$1.parseIdent(true);\r\n      if (this$1.eatContextual(\"as\")) {\r\n        node$2.local = this$1.parseIdent();\r\n      } else {\r\n        this$1.checkUnreserved(node$2.imported);\r\n        node$2.local = node$2.imported;\r\n      }\r\n      this$1.checkLVal(node$2.local, \"let\");\r\n      nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"));\r\n    }\r\n    return nodes\r\n  };\r\n\r\n  // Set `ExpressionStatement#directive` property for directive prologues.\r\n  pp$1.adaptDirectivePrologue = function(statements) {\r\n    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\r\n      statements[i].directive = statements[i].expression.raw.slice(1, -1);\r\n    }\r\n  };\r\n  pp$1.isDirectiveCandidate = function(statement) {\r\n    return (\r\n      statement.type === \"ExpressionStatement\" &&\r\n      statement.expression.type === \"Literal\" &&\r\n      typeof statement.expression.value === \"string\" &&\r\n      // Reject parenthesized strings.\r\n      (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\r\n    )\r\n  };\r\n\r\n  var pp$2 = Parser.prototype;\r\n\r\n  // Convert existing expression atom to assignable pattern\r\n  // if possible.\r\n\r\n  pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\r\n    var this$1 = this;\r\n\r\n    if (this.options.ecmaVersion >= 6 && node) {\r\n      switch (node.type) {\r\n      case \"Identifier\":\r\n        if (this.inAsync && node.name === \"await\")\r\n          { this.raise(node.start, \"Can not use 'await' as identifier inside an async function\"); }\r\n        break\r\n\r\n      case \"ObjectPattern\":\r\n      case \"ArrayPattern\":\r\n      case \"RestElement\":\r\n        break\r\n\r\n      case \"ObjectExpression\":\r\n        node.type = \"ObjectPattern\";\r\n        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\r\n        for (var i = 0, list = node.properties; i < list.length; i += 1) {\r\n          var prop = list[i];\r\n\r\n        this$1.toAssignable(prop, isBinding);\r\n          // Early error:\r\n          //   AssignmentRestProperty[Yield, Await] :\r\n          //     `...` DestructuringAssignmentTarget[Yield, Await]\r\n          //\r\n          //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\r\n          if (\r\n            prop.type === \"RestElement\" &&\r\n            (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\r\n          ) {\r\n            this$1.raise(prop.argument.start, \"Unexpected token\");\r\n          }\r\n        }\r\n        break\r\n\r\n      case \"Property\":\r\n        // AssignmentProperty has type === \"Property\"\r\n        if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\r\n        this.toAssignable(node.value, isBinding);\r\n        break\r\n\r\n      case \"ArrayExpression\":\r\n        node.type = \"ArrayPattern\";\r\n        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\r\n        this.toAssignableList(node.elements, isBinding);\r\n        break\r\n\r\n      case \"SpreadElement\":\r\n        node.type = \"RestElement\";\r\n        this.toAssignable(node.argument, isBinding);\r\n        if (node.argument.type === \"AssignmentPattern\")\r\n          { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\r\n        break\r\n\r\n      case \"AssignmentExpression\":\r\n        if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\r\n        node.type = \"AssignmentPattern\";\r\n        delete node.operator;\r\n        this.toAssignable(node.left, isBinding);\r\n        // falls through to AssignmentPattern\r\n\r\n      case \"AssignmentPattern\":\r\n        break\r\n\r\n      case \"ParenthesizedExpression\":\r\n        this.toAssignable(node.expression, isBinding);\r\n        break\r\n\r\n      case \"MemberExpression\":\r\n        if (!isBinding) { break }\r\n\r\n      default:\r\n        this.raise(node.start, \"Assigning to rvalue\");\r\n      }\r\n    } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\r\n    return node\r\n  };\r\n\r\n  // Convert list of expression atoms to binding list.\r\n\r\n  pp$2.toAssignableList = function(exprList, isBinding) {\r\n    var this$1 = this;\r\n\r\n    var end = exprList.length;\r\n    for (var i = 0; i < end; i++) {\r\n      var elt = exprList[i];\r\n      if (elt) { this$1.toAssignable(elt, isBinding); }\r\n    }\r\n    if (end) {\r\n      var last = exprList[end - 1];\r\n      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\r\n        { this.unexpected(last.argument.start); }\r\n    }\r\n    return exprList\r\n  };\r\n\r\n  // Parses spread element.\r\n\r\n  pp$2.parseSpread = function(refDestructuringErrors) {\r\n    var node = this.startNode();\r\n    this.next();\r\n    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\r\n    return this.finishNode(node, \"SpreadElement\")\r\n  };\r\n\r\n  pp$2.parseRestBinding = function() {\r\n    var node = this.startNode();\r\n    this.next();\r\n\r\n    // RestElement inside of a function parameter must be an identifier\r\n    if (this.options.ecmaVersion === 6 && this.type !== types.name)\r\n      { this.unexpected(); }\r\n\r\n    node.argument = this.parseBindingAtom();\r\n\r\n    return this.finishNode(node, \"RestElement\")\r\n  };\r\n\r\n  // Parses lvalue (assignable) atom.\r\n\r\n  pp$2.parseBindingAtom = function() {\r\n    if (this.options.ecmaVersion >= 6) {\r\n      switch (this.type) {\r\n      case types.bracketL:\r\n        var node = this.startNode();\r\n        this.next();\r\n        node.elements = this.parseBindingList(types.bracketR, true, true);\r\n        return this.finishNode(node, \"ArrayPattern\")\r\n\r\n      case types.braceL:\r\n        return this.parseObj(true)\r\n      }\r\n    }\r\n    return this.parseIdent()\r\n  };\r\n\r\n  pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\r\n    var this$1 = this;\r\n\r\n    var elts = [], first = true;\r\n    while (!this.eat(close)) {\r\n      if (first) { first = false; }\r\n      else { this$1.expect(types.comma); }\r\n      if (allowEmpty && this$1.type === types.comma) {\r\n        elts.push(null);\r\n      } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {\r\n        break\r\n      } else if (this$1.type === types.ellipsis) {\r\n        var rest = this$1.parseRestBinding();\r\n        this$1.parseBindingListItem(rest);\r\n        elts.push(rest);\r\n        if (this$1.type === types.comma) { this$1.raise(this$1.start, \"Comma is not permitted after the rest element\"); }\r\n        this$1.expect(close);\r\n        break\r\n      } else {\r\n        var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);\r\n        this$1.parseBindingListItem(elem);\r\n        elts.push(elem);\r\n      }\r\n    }\r\n    return elts\r\n  };\r\n\r\n  pp$2.parseBindingListItem = function(param) {\r\n    return param\r\n  };\r\n\r\n  // Parses assignment pattern around given atom if possible.\r\n\r\n  pp$2.parseMaybeDefault = function(startPos, startLoc, left) {\r\n    left = left || this.parseBindingAtom();\r\n    if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }\r\n    var node = this.startNodeAt(startPos, startLoc);\r\n    node.left = left;\r\n    node.right = this.parseMaybeAssign();\r\n    return this.finishNode(node, \"AssignmentPattern\")\r\n  };\r\n\r\n  // Verify that a node is an lval  something that can be assigned\r\n  // to.\r\n  // bindingType can be either:\r\n  // 'var' indicating that the lval creates a 'var' binding\r\n  // 'let' indicating that the lval creates a lexical ('let' or 'const') binding\r\n  // 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\r\n\r\n  pp$2.checkLVal = function(expr, bindingType, checkClashes) {\r\n    var this$1 = this;\r\n\r\n    switch (expr.type) {\r\n    case \"Identifier\":\r\n      if (this.strict && this.reservedWordsStrictBind.test(expr.name))\r\n        { this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\r\n      if (checkClashes) {\r\n        if (has(checkClashes, expr.name))\r\n          { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\r\n        checkClashes[expr.name] = true;\r\n      }\r\n      if (bindingType && bindingType !== \"none\") {\r\n        if (\r\n          bindingType === \"var\" && !this.canDeclareVarName(expr.name) ||\r\n          bindingType !== \"var\" && !this.canDeclareLexicalName(expr.name)\r\n        ) {\r\n          this.raiseRecoverable(expr.start, (\"Identifier '\" + (expr.name) + \"' has already been declared\"));\r\n        }\r\n        if (bindingType === \"var\") {\r\n          this.declareVarName(expr.name);\r\n        } else {\r\n          this.declareLexicalName(expr.name);\r\n        }\r\n      }\r\n      break\r\n\r\n    case \"MemberExpression\":\r\n      if (bindingType) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\r\n      break\r\n\r\n    case \"ObjectPattern\":\r\n      for (var i = 0, list = expr.properties; i < list.length; i += 1)\r\n        {\r\n      var prop = list[i];\r\n\r\n      this$1.checkLVal(prop, bindingType, checkClashes);\r\n    }\r\n      break\r\n\r\n    case \"Property\":\r\n      // AssignmentProperty has type === \"Property\"\r\n      this.checkLVal(expr.value, bindingType, checkClashes);\r\n      break\r\n\r\n    case \"ArrayPattern\":\r\n      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\r\n        var elem = list$1[i$1];\r\n\r\n      if (elem) { this$1.checkLVal(elem, bindingType, checkClashes); }\r\n      }\r\n      break\r\n\r\n    case \"AssignmentPattern\":\r\n      this.checkLVal(expr.left, bindingType, checkClashes);\r\n      break\r\n\r\n    case \"RestElement\":\r\n      this.checkLVal(expr.argument, bindingType, checkClashes);\r\n      break\r\n\r\n    case \"ParenthesizedExpression\":\r\n      this.checkLVal(expr.expression, bindingType, checkClashes);\r\n      break\r\n\r\n    default:\r\n      this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\r\n    }\r\n  };\r\n\r\n  // A recursive descent parser operates by defining functions for all\r\n  // syntactic elements, and recursively calling those, each function\r\n  // advancing the input stream and returning an AST node. Precedence\r\n  // of constructs (for example, the fact that `!x[1]` means `!(x[1])`\r\n  // instead of `(!x)[1]` is handled by the fact that the parser\r\n  // function that parses unary prefix operators is called first, and\r\n  // in turn calls the function that parses `[]` subscripts  that\r\n  // way, it'll receive the node for `x[1]` already parsed, and wraps\r\n  // *that* in the unary operator node.\r\n  //\r\n  // Acorn uses an [operator precedence parser][opp] to handle binary\r\n  // operator precedence, because it is much more compact than using\r\n  // the technique outlined above, which uses different, nesting\r\n  // functions to specify precedence, for all of the ten binary\r\n  // precedence levels that JavaScript defines.\r\n  //\r\n  // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\r\n\r\n  var pp$3 = Parser.prototype;\r\n\r\n  // Check if property name clashes with already added.\r\n  // Object/class getters and setters are not allowed to clash \r\n  // either with each other or with an init property  and in\r\n  // strict mode, init properties are also not allowed to be repeated.\r\n\r\n  pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {\r\n    if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\r\n      { return }\r\n    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\r\n      { return }\r\n    var key = prop.key;\r\n    var name;\r\n    switch (key.type) {\r\n    case \"Identifier\": name = key.name; break\r\n    case \"Literal\": name = String(key.value); break\r\n    default: return\r\n    }\r\n    var kind = prop.kind;\r\n    if (this.options.ecmaVersion >= 6) {\r\n      if (name === \"__proto__\" && kind === \"init\") {\r\n        if (propHash.proto) {\r\n          if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }\r\n          // Backwards-compat kludge. Can be removed in version 6.0\r\n          else { this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\"); }\r\n        }\r\n        propHash.proto = true;\r\n      }\r\n      return\r\n    }\r\n    name = \"$\" + name;\r\n    var other = propHash[name];\r\n    if (other) {\r\n      var redefinition;\r\n      if (kind === \"init\") {\r\n        redefinition = this.strict && other.init || other.get || other.set;\r\n      } else {\r\n        redefinition = other.init || other[kind];\r\n      }\r\n      if (redefinition)\r\n        { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\r\n    } else {\r\n      other = propHash[name] = {\r\n        init: false,\r\n        get: false,\r\n        set: false\r\n      };\r\n    }\r\n    other[kind] = true;\r\n  };\r\n\r\n  // ### Expression parsing\r\n\r\n  // These nest, from the most general expression type at the top to\r\n  // 'atomic', nondivisible expression types at the bottom. Most of\r\n  // the functions will simply let the function(s) below them parse,\r\n  // and, *if* the syntactic construct they handle is present, wrap\r\n  // the AST node that the inner parser gave them in another node.\r\n\r\n  // Parse a full expression. The optional arguments are used to\r\n  // forbid the `in` operator (in for loops initalization expressions)\r\n  // and provide reference for storing '=' operator inside shorthand\r\n  // property assignment in contexts where both object expression\r\n  // and object pattern might appear (so it's possible to raise\r\n  // delayed syntax error at correct position).\r\n\r\n  pp$3.parseExpression = function(noIn, refDestructuringErrors) {\r\n    var this$1 = this;\r\n\r\n    var startPos = this.start, startLoc = this.startLoc;\r\n    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\r\n    if (this.type === types.comma) {\r\n      var node = this.startNodeAt(startPos, startLoc);\r\n      node.expressions = [expr];\r\n      while (this.eat(types.comma)) { node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors)); }\r\n      return this.finishNode(node, \"SequenceExpression\")\r\n    }\r\n    return expr\r\n  };\r\n\r\n  // Parse an assignment expression. This includes applications of\r\n  // operators like `+=`.\r\n\r\n  pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\r\n    if (this.inGenerator && this.isContextual(\"yield\")) { return this.parseYield() }\r\n\r\n    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;\r\n    if (refDestructuringErrors) {\r\n      oldParenAssign = refDestructuringErrors.parenthesizedAssign;\r\n      oldTrailingComma = refDestructuringErrors.trailingComma;\r\n      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\r\n    } else {\r\n      refDestructuringErrors = new DestructuringErrors;\r\n      ownDestructuringErrors = true;\r\n    }\r\n\r\n    var startPos = this.start, startLoc = this.startLoc;\r\n    if (this.type === types.parenL || this.type === types.name)\r\n      { this.potentialArrowAt = this.start; }\r\n    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\r\n    if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\r\n    if (this.type.isAssign) {\r\n      var node = this.startNodeAt(startPos, startLoc);\r\n      node.operator = this.value;\r\n      node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\r\n      if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }\r\n      refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly\r\n      this.checkLVal(left);\r\n      this.next();\r\n      node.right = this.parseMaybeAssign(noIn);\r\n      return this.finishNode(node, \"AssignmentExpression\")\r\n    } else {\r\n      if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\r\n    }\r\n    if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\r\n    if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\r\n    return left\r\n  };\r\n\r\n  // Parse a ternary conditional (`?:`) operator.\r\n\r\n  pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\r\n    var startPos = this.start, startLoc = this.startLoc;\r\n    var expr = this.parseExprOps(noIn, refDestructuringErrors);\r\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\r\n    if (this.eat(types.question)) {\r\n      var node = this.startNodeAt(startPos, startLoc);\r\n      node.test = expr;\r\n      node.consequent = this.parseMaybeAssign();\r\n      this.expect(types.colon);\r\n      node.alternate = this.parseMaybeAssign(noIn);\r\n      return this.finishNode(node, \"ConditionalExpression\")\r\n    }\r\n    return expr\r\n  };\r\n\r\n  // Start the precedence parser.\r\n\r\n  pp$3.parseExprOps = function(noIn, refDestructuringErrors) {\r\n    var startPos = this.start, startLoc = this.startLoc;\r\n    var expr = this.parseMaybeUnary(refDestructuringErrors, false);\r\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\r\n    return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\r\n  };\r\n\r\n  // Parse binary operators with the operator precedence parsing\r\n  // algorithm. `left` is the left-hand side of the operator.\r\n  // `minPrec` provides context that allows the function to stop and\r\n  // defer further parser to one of its callers when it encounters an\r\n  // operator that has a lower precedence than the set it is parsing.\r\n\r\n  pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\r\n    var prec = this.type.binop;\r\n    if (prec != null && (!noIn || this.type !== types._in)) {\r\n      if (prec > minPrec) {\r\n        var logical = this.type === types.logicalOR || this.type === types.logicalAND;\r\n        var op = this.value;\r\n        this.next();\r\n        var startPos = this.start, startLoc = this.startLoc;\r\n        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\r\n        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\r\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\r\n      }\r\n    }\r\n    return left\r\n  };\r\n\r\n  pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\r\n    var node = this.startNodeAt(startPos, startLoc);\r\n    node.left = left;\r\n    node.operator = op;\r\n    node.right = right;\r\n    return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\r\n  };\r\n\r\n  // Parse unary operators, both prefix and postfix.\r\n\r\n  pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\r\n    var this$1 = this;\r\n\r\n    var startPos = this.start, startLoc = this.startLoc, expr;\r\n    if (this.isContextual(\"await\") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {\r\n      expr = this.parseAwait();\r\n      sawUnary = true;\r\n    } else if (this.type.prefix) {\r\n      var node = this.startNode(), update = this.type === types.incDec;\r\n      node.operator = this.value;\r\n      node.prefix = true;\r\n      this.next();\r\n      node.argument = this.parseMaybeUnary(null, true);\r\n      this.checkExpressionErrors(refDestructuringErrors, true);\r\n      if (update) { this.checkLVal(node.argument); }\r\n      else if (this.strict && node.operator === \"delete\" &&\r\n               node.argument.type === \"Identifier\")\r\n        { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\r\n      else { sawUnary = true; }\r\n      expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\r\n    } else {\r\n      expr = this.parseExprSubscripts(refDestructuringErrors);\r\n      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\r\n      while (this.type.postfix && !this.canInsertSemicolon()) {\r\n        var node$1 = this$1.startNodeAt(startPos, startLoc);\r\n        node$1.operator = this$1.value;\r\n        node$1.prefix = false;\r\n        node$1.argument = expr;\r\n        this$1.checkLVal(expr);\r\n        this$1.next();\r\n        expr = this$1.finishNode(node$1, \"UpdateExpression\");\r\n      }\r\n    }\r\n\r\n    if (!sawUnary && this.eat(types.starstar))\r\n      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false) }\r\n    else\r\n      { return expr }\r\n  };\r\n\r\n  // Parse call, dot, and `[]`-subscript expressions.\r\n\r\n  pp$3.parseExprSubscripts = function(refDestructuringErrors) {\r\n    var startPos = this.start, startLoc = this.startLoc;\r\n    var expr = this.parseExprAtom(refDestructuringErrors);\r\n    var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\";\r\n    if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }\r\n    var result = this.parseSubscripts(expr, startPos, startLoc);\r\n    if (refDestructuringErrors && result.type === \"MemberExpression\") {\r\n      if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\r\n      if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\r\n    }\r\n    return result\r\n  };\r\n\r\n  pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\r\n    var this$1 = this;\r\n\r\n    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\r\n        this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === \"async\";\r\n    for (var computed = (void 0);;) {\r\n      if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {\r\n        var node = this$1.startNodeAt(startPos, startLoc);\r\n        node.object = base;\r\n        node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);\r\n        node.computed = !!computed;\r\n        if (computed) { this$1.expect(types.bracketR); }\r\n        base = this$1.finishNode(node, \"MemberExpression\");\r\n      } else if (!noCalls && this$1.eat(types.parenL)) {\r\n        var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos;\r\n        this$1.yieldPos = 0;\r\n        this$1.awaitPos = 0;\r\n        var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);\r\n        if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {\r\n          this$1.checkPatternErrors(refDestructuringErrors, false);\r\n          this$1.checkYieldAwaitInDefaultParams();\r\n          this$1.yieldPos = oldYieldPos;\r\n          this$1.awaitPos = oldAwaitPos;\r\n          return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)\r\n        }\r\n        this$1.checkExpressionErrors(refDestructuringErrors, true);\r\n        this$1.yieldPos = oldYieldPos || this$1.yieldPos;\r\n        this$1.awaitPos = oldAwaitPos || this$1.awaitPos;\r\n        var node$1 = this$1.startNodeAt(startPos, startLoc);\r\n        node$1.callee = base;\r\n        node$1.arguments = exprList;\r\n        base = this$1.finishNode(node$1, \"CallExpression\");\r\n      } else if (this$1.type === types.backQuote) {\r\n        var node$2 = this$1.startNodeAt(startPos, startLoc);\r\n        node$2.tag = base;\r\n        node$2.quasi = this$1.parseTemplate({isTagged: true});\r\n        base = this$1.finishNode(node$2, \"TaggedTemplateExpression\");\r\n      } else {\r\n        return base\r\n      }\r\n    }\r\n  };\r\n\r\n  // Parse an atomic expression  either a single token that is an\r\n  // expression, an expression started by a keyword like `function` or\r\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\r\n  // or `{}`.\r\n\r\n  pp$3.parseExprAtom = function(refDestructuringErrors) {\r\n    var node, canBeArrow = this.potentialArrowAt === this.start;\r\n    switch (this.type) {\r\n    case types._super:\r\n      if (!this.inFunction)\r\n        { this.raise(this.start, \"'super' outside of function or class\"); }\r\n      node = this.startNode();\r\n      this.next();\r\n      // The `super` keyword can appear at below:\r\n      // SuperProperty:\r\n      //     super [ Expression ]\r\n      //     super . IdentifierName\r\n      // SuperCall:\r\n      //     super Arguments\r\n      if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)\r\n        { this.unexpected(); }\r\n      return this.finishNode(node, \"Super\")\r\n\r\n    case types._this:\r\n      node = this.startNode();\r\n      this.next();\r\n      return this.finishNode(node, \"ThisExpression\")\r\n\r\n    case types.name:\r\n      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\r\n      var id = this.parseIdent(this.type !== types.name);\r\n      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\r\n        { return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true) }\r\n      if (canBeArrow && !this.canInsertSemicolon()) {\r\n        if (this.eat(types.arrow))\r\n          { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\r\n        if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\r\n          id = this.parseIdent();\r\n          if (this.canInsertSemicolon() || !this.eat(types.arrow))\r\n            { this.unexpected(); }\r\n          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\r\n        }\r\n      }\r\n      return id\r\n\r\n    case types.regexp:\r\n      var value = this.value;\r\n      node = this.parseLiteral(value.value);\r\n      node.regex = {pattern: value.pattern, flags: value.flags};\r\n      return node\r\n\r\n    case types.num: case types.string:\r\n      return this.parseLiteral(this.value)\r\n\r\n    case types._null: case types._true: case types._false:\r\n      node = this.startNode();\r\n      node.value = this.type === types._null ? null : this.type === types._true;\r\n      node.raw = this.type.keyword;\r\n      this.next();\r\n      return this.finishNode(node, \"Literal\")\r\n\r\n    case types.parenL:\r\n      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);\r\n      if (refDestructuringErrors) {\r\n        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\r\n          { refDestructuringErrors.parenthesizedAssign = start; }\r\n        if (refDestructuringErrors.parenthesizedBind < 0)\r\n          { refDestructuringErrors.parenthesizedBind = start; }\r\n      }\r\n      return expr\r\n\r\n    case types.bracketL:\r\n      node = this.startNode();\r\n      this.next();\r\n      node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\r\n      return this.finishNode(node, \"ArrayExpression\")\r\n\r\n    case types.braceL:\r\n      return this.parseObj(false, refDestructuringErrors)\r\n\r\n    case types._function:\r\n      node = this.startNode();\r\n      this.next();\r\n      return this.parseFunction(node, false)\r\n\r\n    case types._class:\r\n      return this.parseClass(this.startNode(), false)\r\n\r\n    case types._new:\r\n      return this.parseNew()\r\n\r\n    case types.backQuote:\r\n      return this.parseTemplate()\r\n\r\n    default:\r\n      this.unexpected();\r\n    }\r\n  };\r\n\r\n  pp$3.parseLiteral = function(value) {\r\n    var node = this.startNode();\r\n    node.value = value;\r\n    node.raw = this.input.slice(this.start, this.end);\r\n    this.next();\r\n    return this.finishNode(node, \"Literal\")\r\n  };\r\n\r\n  pp$3.parseParenExpression = function() {\r\n    this.expect(types.parenL);\r\n    var val = this.parseExpression();\r\n    this.expect(types.parenR);\r\n    return val\r\n  };\r\n\r\n  pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\r\n    var this$1 = this;\r\n\r\n    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\r\n    if (this.options.ecmaVersion >= 6) {\r\n      this.next();\r\n\r\n      var innerStartPos = this.start, innerStartLoc = this.startLoc;\r\n      var exprList = [], first = true, lastIsComma = false;\r\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\r\n      this.yieldPos = 0;\r\n      this.awaitPos = 0;\r\n      while (this.type !== types.parenR) {\r\n        first ? first = false : this$1.expect(types.comma);\r\n        if (allowTrailingComma && this$1.afterTrailingComma(types.parenR, true)) {\r\n          lastIsComma = true;\r\n          break\r\n        } else if (this$1.type === types.ellipsis) {\r\n          spreadStart = this$1.start;\r\n          exprList.push(this$1.parseParenItem(this$1.parseRestBinding()));\r\n          if (this$1.type === types.comma) { this$1.raise(this$1.start, \"Comma is not permitted after the rest element\"); }\r\n          break\r\n        } else {\r\n          exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));\r\n        }\r\n      }\r\n      var innerEndPos = this.start, innerEndLoc = this.startLoc;\r\n      this.expect(types.parenR);\r\n\r\n      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\r\n        this.checkPatternErrors(refDestructuringErrors, false);\r\n        this.checkYieldAwaitInDefaultParams();\r\n        this.yieldPos = oldYieldPos;\r\n        this.awaitPos = oldAwaitPos;\r\n        return this.parseParenArrowList(startPos, startLoc, exprList)\r\n      }\r\n\r\n      if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\r\n      if (spreadStart) { this.unexpected(spreadStart); }\r\n      this.checkExpressionErrors(refDestructuringErrors, true);\r\n      this.yieldPos = oldYieldPos || this.yieldPos;\r\n      this.awaitPos = oldAwaitPos || this.awaitPos;\r\n\r\n      if (exprList.length > 1) {\r\n        val = this.startNodeAt(innerStartPos, innerStartLoc);\r\n        val.expressions = exprList;\r\n        this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\r\n      } else {\r\n        val = exprList[0];\r\n      }\r\n    } else {\r\n      val = this.parseParenExpression();\r\n    }\r\n\r\n    if (this.options.preserveParens) {\r\n      var par = this.startNodeAt(startPos, startLoc);\r\n      par.expression = val;\r\n      return this.finishNode(par, \"ParenthesizedExpression\")\r\n    } else {\r\n      return val\r\n    }\r\n  };\r\n\r\n  pp$3.parseParenItem = function(item) {\r\n    return item\r\n  };\r\n\r\n  pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\r\n    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\r\n  };\r\n\r\n  // New's precedence is slightly tricky. It must allow its argument to\r\n  // be a `[]` or dot subscript expression, but not a call  at least,\r\n  // not without wrapping it in parentheses. Thus, it uses the noCalls\r\n  // argument to parseSubscripts to prevent it from consuming the\r\n  // argument list.\r\n\r\n  var empty$1 = [];\r\n\r\n  pp$3.parseNew = function() {\r\n    var node = this.startNode();\r\n    var meta = this.parseIdent(true);\r\n    if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\r\n      node.meta = meta;\r\n      var containsEsc = this.containsEsc;\r\n      node.property = this.parseIdent(true);\r\n      if (node.property.name !== \"target\" || containsEsc)\r\n        { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\"); }\r\n      if (!this.inFunction)\r\n        { this.raiseRecoverable(node.start, \"new.target can only be used in functions\"); }\r\n      return this.finishNode(node, \"MetaProperty\")\r\n    }\r\n    var startPos = this.start, startLoc = this.startLoc;\r\n    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\r\n    if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }\r\n    else { node.arguments = empty$1; }\r\n    return this.finishNode(node, \"NewExpression\")\r\n  };\r\n\r\n  // Parse template expression.\r\n\r\n  pp$3.parseTemplateElement = function(ref) {\r\n    var isTagged = ref.isTagged;\r\n\r\n    var elem = this.startNode();\r\n    if (this.type === types.invalidTemplate) {\r\n      if (!isTagged) {\r\n        this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\r\n      }\r\n      elem.value = {\r\n        raw: this.value,\r\n        cooked: null\r\n      };\r\n    } else {\r\n      elem.value = {\r\n        raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\r\n        cooked: this.value\r\n      };\r\n    }\r\n    this.next();\r\n    elem.tail = this.type === types.backQuote;\r\n    return this.finishNode(elem, \"TemplateElement\")\r\n  };\r\n\r\n  pp$3.parseTemplate = function(ref) {\r\n    var this$1 = this;\r\n    if ( ref === void 0 ) ref = {};\r\n    var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\r\n\r\n    var node = this.startNode();\r\n    this.next();\r\n    node.expressions = [];\r\n    var curElt = this.parseTemplateElement({isTagged: isTagged});\r\n    node.quasis = [curElt];\r\n    while (!curElt.tail) {\r\n      this$1.expect(types.dollarBraceL);\r\n      node.expressions.push(this$1.parseExpression());\r\n      this$1.expect(types.braceR);\r\n      node.quasis.push(curElt = this$1.parseTemplateElement({isTagged: isTagged}));\r\n    }\r\n    this.next();\r\n    return this.finishNode(node, \"TemplateLiteral\")\r\n  };\r\n\r\n  pp$3.isAsyncProp = function(prop) {\r\n    return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\r\n      (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&\r\n      !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\r\n  };\r\n\r\n  // Parse an object literal or binding pattern.\r\n\r\n  pp$3.parseObj = function(isPattern, refDestructuringErrors) {\r\n    var this$1 = this;\r\n\r\n    var node = this.startNode(), first = true, propHash = {};\r\n    node.properties = [];\r\n    this.next();\r\n    while (!this.eat(types.braceR)) {\r\n      if (!first) {\r\n        this$1.expect(types.comma);\r\n        if (this$1.afterTrailingComma(types.braceR)) { break }\r\n      } else { first = false; }\r\n\r\n      var prop = this$1.parseProperty(isPattern, refDestructuringErrors);\r\n      if (!isPattern) { this$1.checkPropClash(prop, propHash, refDestructuringErrors); }\r\n      node.properties.push(prop);\r\n    }\r\n    return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\r\n  };\r\n\r\n  pp$3.parseProperty = function(isPattern, refDestructuringErrors) {\r\n    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\r\n    if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\r\n      if (isPattern) {\r\n        prop.argument = this.parseIdent(false);\r\n        if (this.type === types.comma) {\r\n          this.raise(this.start, \"Comma is not permitted after the rest element\");\r\n        }\r\n        return this.finishNode(prop, \"RestElement\")\r\n      }\r\n      // To disallow parenthesized identifier via `this.toAssignable()`.\r\n      if (this.type === types.parenL && refDestructuringErrors) {\r\n        if (refDestructuringErrors.parenthesizedAssign < 0) {\r\n          refDestructuringErrors.parenthesizedAssign = this.start;\r\n        }\r\n        if (refDestructuringErrors.parenthesizedBind < 0) {\r\n          refDestructuringErrors.parenthesizedBind = this.start;\r\n        }\r\n      }\r\n      // Parse argument.\r\n      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\r\n      // To disallow trailing comma via `this.toAssignable()`.\r\n      if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\r\n        refDestructuringErrors.trailingComma = this.start;\r\n      }\r\n      // Finish\r\n      return this.finishNode(prop, \"SpreadElement\")\r\n    }\r\n    if (this.options.ecmaVersion >= 6) {\r\n      prop.method = false;\r\n      prop.shorthand = false;\r\n      if (isPattern || refDestructuringErrors) {\r\n        startPos = this.start;\r\n        startLoc = this.startLoc;\r\n      }\r\n      if (!isPattern)\r\n        { isGenerator = this.eat(types.star); }\r\n    }\r\n    var containsEsc = this.containsEsc;\r\n    this.parsePropertyName(prop);\r\n    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\r\n      isAsync = true;\r\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\r\n      this.parsePropertyName(prop, refDestructuringErrors);\r\n    } else {\r\n      isAsync = false;\r\n    }\r\n    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\r\n    return this.finishNode(prop, \"Property\")\r\n  };\r\n\r\n  pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\r\n    if ((isGenerator || isAsync) && this.type === types.colon)\r\n      { this.unexpected(); }\r\n\r\n    if (this.eat(types.colon)) {\r\n      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\r\n      prop.kind = \"init\";\r\n    } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\r\n      if (isPattern) { this.unexpected(); }\r\n      prop.kind = \"init\";\r\n      prop.method = true;\r\n      prop.value = this.parseMethod(isGenerator, isAsync);\r\n    } else if (!isPattern && !containsEsc &&\r\n               this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\r\n               (prop.key.name === \"get\" || prop.key.name === \"set\") &&\r\n               (this.type !== types.comma && this.type !== types.braceR)) {\r\n      if (isGenerator || isAsync) { this.unexpected(); }\r\n      prop.kind = prop.key.name;\r\n      this.parsePropertyName(prop);\r\n      prop.value = this.parseMethod(false);\r\n      var paramCount = prop.kind === \"get\" ? 0 : 1;\r\n      if (prop.value.params.length !== paramCount) {\r\n        var start = prop.value.start;\r\n        if (prop.kind === \"get\")\r\n          { this.raiseRecoverable(start, \"getter should have no params\"); }\r\n        else\r\n          { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\r\n      } else {\r\n        if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\r\n          { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\r\n      }\r\n    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\r\n      this.checkUnreserved(prop.key);\r\n      prop.kind = \"init\";\r\n      if (isPattern) {\r\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\r\n      } else if (this.type === types.eq && refDestructuringErrors) {\r\n        if (refDestructuringErrors.shorthandAssign < 0)\r\n          { refDestructuringErrors.shorthandAssign = this.start; }\r\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\r\n      } else {\r\n        prop.value = prop.key;\r\n      }\r\n      prop.shorthand = true;\r\n    } else { this.unexpected(); }\r\n  };\r\n\r\n  pp$3.parsePropertyName = function(prop) {\r\n    if (this.options.ecmaVersion >= 6) {\r\n      if (this.eat(types.bracketL)) {\r\n        prop.computed = true;\r\n        prop.key = this.parseMaybeAssign();\r\n        this.expect(types.bracketR);\r\n        return prop.key\r\n      } else {\r\n        prop.computed = false;\r\n      }\r\n    }\r\n    return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(true)\r\n  };\r\n\r\n  // Initialize empty function node.\r\n\r\n  pp$3.initFunction = function(node) {\r\n    node.id = null;\r\n    if (this.options.ecmaVersion >= 6) {\r\n      node.generator = false;\r\n      node.expression = false;\r\n    }\r\n    if (this.options.ecmaVersion >= 8)\r\n      { node.async = false; }\r\n  };\r\n\r\n  // Parse object or class method.\r\n\r\n  pp$3.parseMethod = function(isGenerator, isAsync) {\r\n    var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,\r\n        oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\r\n\r\n    this.initFunction(node);\r\n    if (this.options.ecmaVersion >= 6)\r\n      { node.generator = isGenerator; }\r\n    if (this.options.ecmaVersion >= 8)\r\n      { node.async = !!isAsync; }\r\n\r\n    this.inGenerator = node.generator;\r\n    this.inAsync = node.async;\r\n    this.yieldPos = 0;\r\n    this.awaitPos = 0;\r\n    this.inFunction = true;\r\n    this.enterFunctionScope();\r\n\r\n    this.expect(types.parenL);\r\n    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\r\n    this.checkYieldAwaitInDefaultParams();\r\n    this.parseFunctionBody(node, false);\r\n\r\n    this.inGenerator = oldInGen;\r\n    this.inAsync = oldInAsync;\r\n    this.yieldPos = oldYieldPos;\r\n    this.awaitPos = oldAwaitPos;\r\n    this.inFunction = oldInFunc;\r\n    return this.finishNode(node, \"FunctionExpression\")\r\n  };\r\n\r\n  // Parse arrow function expression with given parameters.\r\n\r\n  pp$3.parseArrowExpression = function(node, params, isAsync) {\r\n    var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\r\n        oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\r\n\r\n    this.enterFunctionScope();\r\n    this.initFunction(node);\r\n    if (this.options.ecmaVersion >= 8)\r\n      { node.async = !!isAsync; }\r\n\r\n    this.inGenerator = false;\r\n    this.inAsync = node.async;\r\n    this.yieldPos = 0;\r\n    this.awaitPos = 0;\r\n    this.inFunction = true;\r\n\r\n    node.params = this.toAssignableList(params, true);\r\n    this.parseFunctionBody(node, true);\r\n\r\n    this.inGenerator = oldInGen;\r\n    this.inAsync = oldInAsync;\r\n    this.yieldPos = oldYieldPos;\r\n    this.awaitPos = oldAwaitPos;\r\n    this.inFunction = oldInFunc;\r\n    return this.finishNode(node, \"ArrowFunctionExpression\")\r\n  };\r\n\r\n  // Parse function body and check parameters.\r\n\r\n  pp$3.parseFunctionBody = function(node, isArrowFunction) {\r\n    var isExpression = isArrowFunction && this.type !== types.braceL;\r\n    var oldStrict = this.strict, useStrict = false;\r\n\r\n    if (isExpression) {\r\n      node.body = this.parseMaybeAssign();\r\n      node.expression = true;\r\n      this.checkParams(node, false);\r\n    } else {\r\n      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\r\n      if (!oldStrict || nonSimple) {\r\n        useStrict = this.strictDirective(this.end);\r\n        // If this is a strict mode function, verify that argument names\r\n        // are not repeated, and it does not try to bind the words `eval`\r\n        // or `arguments`.\r\n        if (useStrict && nonSimple)\r\n          { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\r\n      }\r\n      // Start a new scope with regard to labels and the `inFunction`\r\n      // flag (restore them to their old value afterwards).\r\n      var oldLabels = this.labels;\r\n      this.labels = [];\r\n      if (useStrict) { this.strict = true; }\r\n\r\n      // Add the params to varDeclaredNames to ensure that an error is thrown\r\n      // if a let/const declaration in the function clashes with one of the params.\r\n      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params));\r\n      node.body = this.parseBlock(false);\r\n      node.expression = false;\r\n      this.adaptDirectivePrologue(node.body.body);\r\n      this.labels = oldLabels;\r\n    }\r\n    this.exitFunctionScope();\r\n\r\n    if (this.strict && node.id) {\r\n      // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\r\n      this.checkLVal(node.id, \"none\");\r\n    }\r\n    this.strict = oldStrict;\r\n  };\r\n\r\n  pp$3.isSimpleParamList = function(params) {\r\n    for (var i = 0, list = params; i < list.length; i += 1)\r\n      {\r\n      var param = list[i];\r\n\r\n      if (param.type !== \"Identifier\") { return false\r\n    } }\r\n    return true\r\n  };\r\n\r\n  // Checks function params for various disallowed patterns such as using \"eval\"\r\n  // or \"arguments\" and duplicate parameters.\r\n\r\n  pp$3.checkParams = function(node, allowDuplicates) {\r\n    var this$1 = this;\r\n\r\n    var nameHash = {};\r\n    for (var i = 0, list = node.params; i < list.length; i += 1)\r\n      {\r\n      var param = list[i];\r\n\r\n      this$1.checkLVal(param, \"var\", allowDuplicates ? null : nameHash);\r\n    }\r\n  };\r\n\r\n  // Parses a comma-separated list of expressions, and returns them as\r\n  // an array. `close` is the token type that ends the list, and\r\n  // `allowEmpty` can be turned on to allow subsequent commas with\r\n  // nothing in between them to be parsed as `null` (which is needed\r\n  // for array literals).\r\n\r\n  pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\r\n    var this$1 = this;\r\n\r\n    var elts = [], first = true;\r\n    while (!this.eat(close)) {\r\n      if (!first) {\r\n        this$1.expect(types.comma);\r\n        if (allowTrailingComma && this$1.afterTrailingComma(close)) { break }\r\n      } else { first = false; }\r\n\r\n      var elt = (void 0);\r\n      if (allowEmpty && this$1.type === types.comma)\r\n        { elt = null; }\r\n      else if (this$1.type === types.ellipsis) {\r\n        elt = this$1.parseSpread(refDestructuringErrors);\r\n        if (refDestructuringErrors && this$1.type === types.comma && refDestructuringErrors.trailingComma < 0)\r\n          { refDestructuringErrors.trailingComma = this$1.start; }\r\n      } else {\r\n        elt = this$1.parseMaybeAssign(false, refDestructuringErrors);\r\n      }\r\n      elts.push(elt);\r\n    }\r\n    return elts\r\n  };\r\n\r\n  pp$3.checkUnreserved = function(ref) {\r\n    var start = ref.start;\r\n    var end = ref.end;\r\n    var name = ref.name;\r\n\r\n    if (this.inGenerator && name === \"yield\")\r\n      { this.raiseRecoverable(start, \"Can not use 'yield' as identifier inside a generator\"); }\r\n    if (this.inAsync && name === \"await\")\r\n      { this.raiseRecoverable(start, \"Can not use 'await' as identifier inside an async function\"); }\r\n    if (this.isKeyword(name))\r\n      { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\r\n    if (this.options.ecmaVersion < 6 &&\r\n      this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\r\n    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\r\n    if (re.test(name)) {\r\n      if (!this.inAsync && name === \"await\")\r\n        { this.raiseRecoverable(start, \"Can not use keyword 'await' outside an async function\"); }\r\n      this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\r\n    }\r\n  };\r\n\r\n  // Parse the next token as an identifier. If `liberal` is true (used\r\n  // when parsing properties), it will also convert keywords into\r\n  // identifiers.\r\n\r\n  pp$3.parseIdent = function(liberal, isBinding) {\r\n    var node = this.startNode();\r\n    if (liberal && this.options.allowReserved === \"never\") { liberal = false; }\r\n    if (this.type === types.name) {\r\n      node.name = this.value;\r\n    } else if (this.type.keyword) {\r\n      node.name = this.type.keyword;\r\n\r\n      // To fix https://github.com/acornjs/acorn/issues/575\r\n      // `class` and `function` keywords push new context into this.context.\r\n      // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\r\n      // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\r\n      if ((node.name === \"class\" || node.name === \"function\") &&\r\n          (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\r\n        this.context.pop();\r\n      }\r\n    } else {\r\n      this.unexpected();\r\n    }\r\n    this.next();\r\n    this.finishNode(node, \"Identifier\");\r\n    if (!liberal) { this.checkUnreserved(node); }\r\n    return node\r\n  };\r\n\r\n  // Parses yield expression inside generator.\r\n\r\n  pp$3.parseYield = function() {\r\n    if (!this.yieldPos) { this.yieldPos = this.start; }\r\n\r\n    var node = this.startNode();\r\n    this.next();\r\n    if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {\r\n      node.delegate = false;\r\n      node.argument = null;\r\n    } else {\r\n      node.delegate = this.eat(types.star);\r\n      node.argument = this.parseMaybeAssign();\r\n    }\r\n    return this.finishNode(node, \"YieldExpression\")\r\n  };\r\n\r\n  pp$3.parseAwait = function() {\r\n    if (!this.awaitPos) { this.awaitPos = this.start; }\r\n\r\n    var node = this.startNode();\r\n    this.next();\r\n    node.argument = this.parseMaybeUnary(null, true);\r\n    return this.finishNode(node, \"AwaitExpression\")\r\n  };\r\n\r\n  var pp$4 = Parser.prototype;\r\n\r\n  // This function is used to raise exceptions on parse errors. It\r\n  // takes an offset integer (into the current `input`) to indicate\r\n  // the location of the error, attaches the position to the end\r\n  // of the error message, and then raises a `SyntaxError` with that\r\n  // message.\r\n\r\n  pp$4.raise = function(pos, message) {\r\n    var loc = getLineInfo(this.input, pos);\r\n    message += \" (\" + loc.line + \":\" + loc.column + \")\";\r\n    var err = new SyntaxError(message);\r\n    err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\r\n    throw err\r\n  };\r\n\r\n  pp$4.raiseRecoverable = pp$4.raise;\r\n\r\n  pp$4.curPosition = function() {\r\n    if (this.options.locations) {\r\n      return new Position(this.curLine, this.pos - this.lineStart)\r\n    }\r\n  };\r\n\r\n  var pp$5 = Parser.prototype;\r\n\r\n  // Object.assign polyfill\r\n  var assign = Object.assign || function(target) {\r\n    var sources = [], len = arguments.length - 1;\r\n    while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\r\n\r\n    for (var i = 0, list = sources; i < list.length; i += 1) {\r\n      var source = list[i];\r\n\r\n      for (var key in source) {\r\n        if (has(source, key)) {\r\n          target[key] = source[key];\r\n        }\r\n      }\r\n    }\r\n    return target\r\n  };\r\n\r\n  // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\r\n\r\n  pp$5.enterFunctionScope = function() {\r\n    // var: a hash of var-declared names in the current lexical scope\r\n    // lexical: a hash of lexically-declared names in the current lexical scope\r\n    // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)\r\n    // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)\r\n    this.scopeStack.push({var: {}, lexical: {}, childVar: {}, parentLexical: {}});\r\n  };\r\n\r\n  pp$5.exitFunctionScope = function() {\r\n    this.scopeStack.pop();\r\n  };\r\n\r\n  pp$5.enterLexicalScope = function() {\r\n    var parentScope = this.scopeStack[this.scopeStack.length - 1];\r\n    var childScope = {var: {}, lexical: {}, childVar: {}, parentLexical: {}};\r\n\r\n    this.scopeStack.push(childScope);\r\n    assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);\r\n  };\r\n\r\n  pp$5.exitLexicalScope = function() {\r\n    var childScope = this.scopeStack.pop();\r\n    var parentScope = this.scopeStack[this.scopeStack.length - 1];\r\n\r\n    assign(parentScope.childVar, childScope.var, childScope.childVar);\r\n  };\r\n\r\n  /**\r\n   * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`\r\n   * in the current lexical scope or any of the parent lexical scopes in this function.\r\n   */\r\n  pp$5.canDeclareVarName = function(name) {\r\n    var currentScope = this.scopeStack[this.scopeStack.length - 1];\r\n\r\n    return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name)\r\n  };\r\n\r\n  /**\r\n   * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`\r\n   * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in\r\n   * any child lexical scopes in this function.\r\n   */\r\n  pp$5.canDeclareLexicalName = function(name) {\r\n    var currentScope = this.scopeStack[this.scopeStack.length - 1];\r\n\r\n    return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name)\r\n  };\r\n\r\n  pp$5.declareVarName = function(name) {\r\n    this.scopeStack[this.scopeStack.length - 1].var[name] = true;\r\n  };\r\n\r\n  pp$5.declareLexicalName = function(name) {\r\n    this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;\r\n  };\r\n\r\n  var Node = function Node(parser, pos, loc) {\r\n    this.type = \"\";\r\n    this.start = pos;\r\n    this.end = 0;\r\n    if (parser.options.locations)\r\n      { this.loc = new SourceLocation(parser, loc); }\r\n    if (parser.options.directSourceFile)\r\n      { this.sourceFile = parser.options.directSourceFile; }\r\n    if (parser.options.ranges)\r\n      { this.range = [pos, 0]; }\r\n  };\r\n\r\n  // Start an AST node, attaching a start offset.\r\n\r\n  var pp$6 = Parser.prototype;\r\n\r\n  pp$6.startNode = function() {\r\n    return new Node(this, this.start, this.startLoc)\r\n  };\r\n\r\n  pp$6.startNodeAt = function(pos, loc) {\r\n    return new Node(this, pos, loc)\r\n  };\r\n\r\n  // Finish an AST node, adding `type` and `end` properties.\r\n\r\n  function finishNodeAt(node, type, pos, loc) {\r\n    node.type = type;\r\n    node.end = pos;\r\n    if (this.options.locations)\r\n      { node.loc.end = loc; }\r\n    if (this.options.ranges)\r\n      { node.range[1] = pos; }\r\n    return node\r\n  }\r\n\r\n  pp$6.finishNode = function(node, type) {\r\n    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\r\n  };\r\n\r\n  // Finish node at given position\r\n\r\n  pp$6.finishNodeAt = function(node, type, pos, loc) {\r\n    return finishNodeAt.call(this, node, type, pos, loc)\r\n  };\r\n\r\n  // The algorithm used to determine whether a regexp can appear at a\r\n  // given point in the program is loosely based on sweet.js' approach.\r\n  // See https://github.com/mozilla/sweet.js/wiki/design\r\n\r\n  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\r\n    this.token = token;\r\n    this.isExpr = !!isExpr;\r\n    this.preserveSpace = !!preserveSpace;\r\n    this.override = override;\r\n    this.generator = !!generator;\r\n  };\r\n\r\n  var types$1 = {\r\n    b_stat: new TokContext(\"{\", false),\r\n    b_expr: new TokContext(\"{\", true),\r\n    b_tmpl: new TokContext(\"${\", false),\r\n    p_stat: new TokContext(\"(\", false),\r\n    p_expr: new TokContext(\"(\", true),\r\n    q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\r\n    f_stat: new TokContext(\"function\", false),\r\n    f_expr: new TokContext(\"function\", true),\r\n    f_expr_gen: new TokContext(\"function\", true, false, null, true),\r\n    f_gen: new TokContext(\"function\", false, false, null, true)\r\n  };\r\n\r\n  var pp$7 = Parser.prototype;\r\n\r\n  pp$7.initialContext = function() {\r\n    return [types$1.b_stat]\r\n  };\r\n\r\n  pp$7.braceIsBlock = function(prevType) {\r\n    var parent = this.curContext();\r\n    if (parent === types$1.f_expr || parent === types$1.f_stat)\r\n      { return true }\r\n    if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))\r\n      { return !parent.isExpr }\r\n\r\n    // The check for `tt.name && exprAllowed` detects whether we are\r\n    // after a `yield` or `of` construct. See the `updateContext` for\r\n    // `tt.name`.\r\n    if (prevType === types._return || prevType === types.name && this.exprAllowed)\r\n      { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\r\n    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)\r\n      { return true }\r\n    if (prevType === types.braceL)\r\n      { return parent === types$1.b_stat }\r\n    if (prevType === types._var || prevType === types.name)\r\n      { return false }\r\n    return !this.exprAllowed\r\n  };\r\n\r\n  pp$7.inGeneratorContext = function() {\r\n    var this$1 = this;\r\n\r\n    for (var i = this.context.length - 1; i >= 1; i--) {\r\n      var context = this$1.context[i];\r\n      if (context.token === \"function\")\r\n        { return context.generator }\r\n    }\r\n    return false\r\n  };\r\n\r\n  pp$7.updateContext = function(prevType) {\r\n    var update, type = this.type;\r\n    if (type.keyword && prevType === types.dot)\r\n      { this.exprAllowed = false; }\r\n    else if (update = type.updateContext)\r\n      { update.call(this, prevType); }\r\n    else\r\n      { this.exprAllowed = type.beforeExpr; }\r\n  };\r\n\r\n  // Token-specific context update code\r\n\r\n  types.parenR.updateContext = types.braceR.updateContext = function() {\r\n    if (this.context.length === 1) {\r\n      this.exprAllowed = true;\r\n      return\r\n    }\r\n    var out = this.context.pop();\r\n    if (out === types$1.b_stat && this.curContext().token === \"function\") {\r\n      out = this.context.pop();\r\n    }\r\n    this.exprAllowed = !out.isExpr;\r\n  };\r\n\r\n  types.braceL.updateContext = function(prevType) {\r\n    this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\r\n    this.exprAllowed = true;\r\n  };\r\n\r\n  types.dollarBraceL.updateContext = function() {\r\n    this.context.push(types$1.b_tmpl);\r\n    this.exprAllowed = true;\r\n  };\r\n\r\n  types.parenL.updateContext = function(prevType) {\r\n    var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\r\n    this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\r\n    this.exprAllowed = true;\r\n  };\r\n\r\n  types.incDec.updateContext = function() {\r\n    // tokExprAllowed stays unchanged\r\n  };\r\n\r\n  types._function.updateContext = types._class.updateContext = function(prevType) {\r\n    if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\r\n        !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\r\n      { this.context.push(types$1.f_expr); }\r\n    else\r\n      { this.context.push(types$1.f_stat); }\r\n    this.exprAllowed = false;\r\n  };\r\n\r\n  types.backQuote.updateContext = function() {\r\n    if (this.curContext() === types$1.q_tmpl)\r\n      { this.context.pop(); }\r\n    else\r\n      { this.context.push(types$1.q_tmpl); }\r\n    this.exprAllowed = false;\r\n  };\r\n\r\n  types.star.updateContext = function(prevType) {\r\n    if (prevType === types._function) {\r\n      var index = this.context.length - 1;\r\n      if (this.context[index] === types$1.f_expr)\r\n        { this.context[index] = types$1.f_expr_gen; }\r\n      else\r\n        { this.context[index] = types$1.f_gen; }\r\n    }\r\n    this.exprAllowed = true;\r\n  };\r\n\r\n  types.name.updateContext = function(prevType) {\r\n    var allowed = false;\r\n    if (this.options.ecmaVersion >= 6) {\r\n      if (this.value === \"of\" && !this.exprAllowed ||\r\n          this.value === \"yield\" && this.inGeneratorContext())\r\n        { allowed = true; }\r\n    }\r\n    this.exprAllowed = allowed;\r\n  };\r\n\r\n  var data = {\r\n    \"$LONE\": [\r\n      \"ASCII\",\r\n      \"ASCII_Hex_Digit\",\r\n      \"AHex\",\r\n      \"Alphabetic\",\r\n      \"Alpha\",\r\n      \"Any\",\r\n      \"Assigned\",\r\n      \"Bidi_Control\",\r\n      \"Bidi_C\",\r\n      \"Bidi_Mirrored\",\r\n      \"Bidi_M\",\r\n      \"Case_Ignorable\",\r\n      \"CI\",\r\n      \"Cased\",\r\n      \"Changes_When_Casefolded\",\r\n      \"CWCF\",\r\n      \"Changes_When_Casemapped\",\r\n      \"CWCM\",\r\n      \"Changes_When_Lowercased\",\r\n      \"CWL\",\r\n      \"Changes_When_NFKC_Casefolded\",\r\n      \"CWKCF\",\r\n      \"Changes_When_Titlecased\",\r\n      \"CWT\",\r\n      \"Changes_When_Uppercased\",\r\n      \"CWU\",\r\n      \"Dash\",\r\n      \"Default_Ignorable_Code_Point\",\r\n      \"DI\",\r\n      \"Deprecated\",\r\n      \"Dep\",\r\n      \"Diacritic\",\r\n      \"Dia\",\r\n      \"Emoji\",\r\n      \"Emoji_Component\",\r\n      \"Emoji_Modifier\",\r\n      \"Emoji_Modifier_Base\",\r\n      \"Emoji_Presentation\",\r\n      \"Extender\",\r\n      \"Ext\",\r\n      \"Grapheme_Base\",\r\n      \"Gr_Base\",\r\n      \"Grapheme_Extend\",\r\n      \"Gr_Ext\",\r\n      \"Hex_Digit\",\r\n      \"Hex\",\r\n      \"IDS_Binary_Operator\",\r\n      \"IDSB\",\r\n      \"IDS_Trinary_Operator\",\r\n      \"IDST\",\r\n      \"ID_Continue\",\r\n      \"IDC\",\r\n      \"ID_Start\",\r\n      \"IDS\",\r\n      \"Ideographic\",\r\n      \"Ideo\",\r\n      \"Join_Control\",\r\n      \"Join_C\",\r\n      \"Logical_Order_Exception\",\r\n      \"LOE\",\r\n      \"Lowercase\",\r\n      \"Lower\",\r\n      \"Math\",\r\n      \"Noncharacter_Code_Point\",\r\n      \"NChar\",\r\n      \"Pattern_Syntax\",\r\n      \"Pat_Syn\",\r\n      \"Pattern_White_Space\",\r\n      \"Pat_WS\",\r\n      \"Quotation_Mark\",\r\n      \"QMark\",\r\n      \"Radical\",\r\n      \"Regional_Indicator\",\r\n      \"RI\",\r\n      \"Sentence_Terminal\",\r\n      \"STerm\",\r\n      \"Soft_Dotted\",\r\n      \"SD\",\r\n      \"Terminal_Punctuation\",\r\n      \"Term\",\r\n      \"Unified_Ideograph\",\r\n      \"UIdeo\",\r\n      \"Uppercase\",\r\n      \"Upper\",\r\n      \"Variation_Selector\",\r\n      \"VS\",\r\n      \"White_Space\",\r\n      \"space\",\r\n      \"XID_Continue\",\r\n      \"XIDC\",\r\n      \"XID_Start\",\r\n      \"XIDS\"\r\n    ],\r\n    \"General_Category\": [\r\n      \"Cased_Letter\",\r\n      \"LC\",\r\n      \"Close_Punctuation\",\r\n      \"Pe\",\r\n      \"Connector_Punctuation\",\r\n      \"Pc\",\r\n      \"Control\",\r\n      \"Cc\",\r\n      \"cntrl\",\r\n      \"Currency_Symbol\",\r\n      \"Sc\",\r\n      \"Dash_Punctuation\",\r\n      \"Pd\",\r\n      \"Decimal_Number\",\r\n      \"Nd\",\r\n      \"digit\",\r\n      \"Enclosing_Mark\",\r\n      \"Me\",\r\n      \"Final_Punctuation\",\r\n      \"Pf\",\r\n      \"Format\",\r\n      \"Cf\",\r\n      \"Initial_Punctuation\",\r\n      \"Pi\",\r\n      \"Letter\",\r\n      \"L\",\r\n      \"Letter_Number\",\r\n      \"Nl\",\r\n      \"Line_Separator\",\r\n      \"Zl\",\r\n      \"Lowercase_Letter\",\r\n      \"Ll\",\r\n      \"Mark\",\r\n      \"M\",\r\n      \"Combining_Mark\",\r\n      \"Math_Symbol\",\r\n      \"Sm\",\r\n      \"Modifier_Letter\",\r\n      \"Lm\",\r\n      \"Modifier_Symbol\",\r\n      \"Sk\",\r\n      \"Nonspacing_Mark\",\r\n      \"Mn\",\r\n      \"Number\",\r\n      \"N\",\r\n      \"Open_Punctuation\",\r\n      \"Ps\",\r\n      \"Other\",\r\n      \"C\",\r\n      \"Other_Letter\",\r\n      \"Lo\",\r\n      \"Other_Number\",\r\n      \"No\",\r\n      \"Other_Punctuation\",\r\n      \"Po\",\r\n      \"Other_Symbol\",\r\n      \"So\",\r\n      \"Paragraph_Separator\",\r\n      \"Zp\",\r\n      \"Private_Use\",\r\n      \"Co\",\r\n      \"Punctuation\",\r\n      \"P\",\r\n      \"punct\",\r\n      \"Separator\",\r\n      \"Z\",\r\n      \"Space_Separator\",\r\n      \"Zs\",\r\n      \"Spacing_Mark\",\r\n      \"Mc\",\r\n      \"Surrogate\",\r\n      \"Cs\",\r\n      \"Symbol\",\r\n      \"S\",\r\n      \"Titlecase_Letter\",\r\n      \"Lt\",\r\n      \"Unassigned\",\r\n      \"Cn\",\r\n      \"Uppercase_Letter\",\r\n      \"Lu\"\r\n    ],\r\n    \"Script\": [\r\n      \"Adlam\",\r\n      \"Adlm\",\r\n      \"Ahom\",\r\n      \"Anatolian_Hieroglyphs\",\r\n      \"Hluw\",\r\n      \"Arabic\",\r\n      \"Arab\",\r\n      \"Armenian\",\r\n      \"Armn\",\r\n      \"Avestan\",\r\n      \"Avst\",\r\n      \"Balinese\",\r\n      \"Bali\",\r\n      \"Bamum\",\r\n      \"Bamu\",\r\n      \"Bassa_Vah\",\r\n      \"Bass\",\r\n      \"Batak\",\r\n      \"Batk\",\r\n      \"Bengali\",\r\n      \"Beng\",\r\n      \"Bhaiksuki\",\r\n      \"Bhks\",\r\n      \"Bopomofo\",\r\n      \"Bopo\",\r\n      \"Brahmi\",\r\n      \"Brah\",\r\n      \"Braille\",\r\n      \"Brai\",\r\n      \"Buginese\",\r\n      \"Bugi\",\r\n      \"Buhid\",\r\n      \"Buhd\",\r\n      \"Canadian_Aboriginal\",\r\n      \"Cans\",\r\n      \"Carian\",\r\n      \"Cari\",\r\n      \"Caucasian_Albanian\",\r\n      \"Aghb\",\r\n      \"Chakma\",\r\n      \"Cakm\",\r\n      \"Cham\",\r\n      \"Cherokee\",\r\n      \"Cher\",\r\n      \"Common\",\r\n      \"Zyyy\",\r\n      \"Coptic\",\r\n      \"Copt\",\r\n      \"Qaac\",\r\n      \"Cuneiform\",\r\n      \"Xsux\",\r\n      \"Cypriot\",\r\n      \"Cprt\",\r\n      \"Cyrillic\",\r\n      \"Cyrl\",\r\n      \"Deseret\",\r\n      \"Dsrt\",\r\n      \"Devanagari\",\r\n      \"Deva\",\r\n      \"Duployan\",\r\n      \"Dupl\",\r\n      \"Egyptian_Hieroglyphs\",\r\n      \"Egyp\",\r\n      \"Elbasan\",\r\n      \"Elba\",\r\n      \"Ethiopic\",\r\n      \"Ethi\",\r\n      \"Georgian\",\r\n      \"Geor\",\r\n      \"Glagolitic\",\r\n      \"Glag\",\r\n      \"Gothic\",\r\n      \"Goth\",\r\n      \"Grantha\",\r\n      \"Gran\",\r\n      \"Greek\",\r\n      \"Grek\",\r\n      \"Gujarati\",\r\n      \"Gujr\",\r\n      \"Gurmukhi\",\r\n      \"Guru\",\r\n      \"Han\",\r\n      \"Hani\",\r\n      \"Hangul\",\r\n      \"Hang\",\r\n      \"Hanunoo\",\r\n      \"Hano\",\r\n      \"Hatran\",\r\n      \"Hatr\",\r\n      \"Hebrew\",\r\n      \"Hebr\",\r\n      \"Hiragana\",\r\n      \"Hira\",\r\n      \"Imperial_Aramaic\",\r\n      \"Armi\",\r\n      \"Inherited\",\r\n      \"Zinh\",\r\n      \"Qaai\",\r\n      \"Inscriptional_Pahlavi\",\r\n      \"Phli\",\r\n      \"Inscriptional_Parthian\",\r\n      \"Prti\",\r\n      \"Javanese\",\r\n      \"Java\",\r\n      \"Kaithi\",\r\n      \"Kthi\",\r\n      \"Kannada\",\r\n      \"Knda\",\r\n      \"Katakana\",\r\n      \"Kana\",\r\n      \"Kayah_Li\",\r\n      \"Kali\",\r\n      \"Kharoshthi\",\r\n      \"Khar\",\r\n      \"Khmer\",\r\n      \"Khmr\",\r\n      \"Khojki\",\r\n      \"Khoj\",\r\n      \"Khudawadi\",\r\n      \"Sind\",\r\n      \"Lao\",\r\n      \"Laoo\",\r\n      \"Latin\",\r\n      \"Latn\",\r\n      \"Lepcha\",\r\n      \"Lepc\",\r\n      \"Limbu\",\r\n      \"Limb\",\r\n      \"Linear_A\",\r\n      \"Lina\",\r\n      \"Linear_B\",\r\n      \"Linb\",\r\n      \"Lisu\",\r\n      \"Lycian\",\r\n      \"Lyci\",\r\n      \"Lydian\",\r\n      \"Lydi\",\r\n      \"Mahajani\",\r\n      \"Mahj\",\r\n      \"Malayalam\",\r\n      \"Mlym\",\r\n      \"Mandaic\",\r\n      \"Mand\",\r\n      \"Manichaean\",\r\n      \"Mani\",\r\n      \"Marchen\",\r\n      \"Marc\",\r\n      \"Masaram_Gondi\",\r\n      \"Gonm\",\r\n      \"Meetei_Mayek\",\r\n      \"Mtei\",\r\n      \"Mende_Kikakui\",\r\n      \"Mend\",\r\n      \"Meroitic_Cursive\",\r\n      \"Merc\",\r\n      \"Meroitic_Hieroglyphs\",\r\n      \"Mero\",\r\n      \"Miao\",\r\n      \"Plrd\",\r\n      \"Modi\",\r\n      \"Mongolian\",\r\n      \"Mong\",\r\n      \"Mro\",\r\n      \"Mroo\",\r\n      \"Multani\",\r\n      \"Mult\",\r\n      \"Myanmar\",\r\n      \"Mymr\",\r\n      \"Nabataean\",\r\n      \"Nbat\",\r\n      \"New_Tai_Lue\",\r\n      \"Talu\",\r\n      \"Newa\",\r\n      \"Nko\",\r\n      \"Nkoo\",\r\n      \"Nushu\",\r\n      \"Nshu\",\r\n      \"Ogham\",\r\n      \"Ogam\",\r\n      \"Ol_Chiki\",\r\n      \"Olck\",\r\n      \"Old_Hungarian\",\r\n      \"Hung\",\r\n      \"Old_Italic\",\r\n      \"Ital\",\r\n      \"Old_North_Arabian\",\r\n      \"Narb\",\r\n      \"Old_Permic\",\r\n      \"Perm\",\r\n      \"Old_Persian\",\r\n      \"Xpeo\",\r\n      \"Old_South_Arabian\",\r\n      \"Sarb\",\r\n      \"Old_Turkic\",\r\n      \"Orkh\",\r\n      \"Oriya\",\r\n      \"Orya\",\r\n      \"Osage\",\r\n      \"Osge\",\r\n      \"Osmanya\",\r\n      \"Osma\",\r\n      \"Pahawh_Hmong\",\r\n      \"Hmng\",\r\n      \"Palmyrene\",\r\n      \"Palm\",\r\n      \"Pau_Cin_Hau\",\r\n      \"Pauc\",\r\n      \"Phags_Pa\",\r\n      \"Phag\",\r\n      \"Phoenician\",\r\n      \"Phnx\",\r\n      \"Psalter_Pahlavi\",\r\n      \"Phlp\",\r\n      \"Rejang\",\r\n      \"Rjng\",\r\n      \"Runic\",\r\n      \"Runr\",\r\n      \"Samaritan\",\r\n      \"Samr\",\r\n      \"Saurashtra\",\r\n      \"Saur\",\r\n      \"Sharada\",\r\n      \"Shrd\",\r\n      \"Shavian\",\r\n      \"Shaw\",\r\n      \"Siddham\",\r\n      \"Sidd\",\r\n      \"SignWriting\",\r\n      \"Sgnw\",\r\n      \"Sinhala\",\r\n      \"Sinh\",\r\n      \"Sora_Sompeng\",\r\n      \"Sora\",\r\n      \"Soyombo\",\r\n      \"Soyo\",\r\n      \"Sundanese\",\r\n      \"Sund\",\r\n      \"Syloti_Nagri\",\r\n      \"Sylo\",\r\n      \"Syriac\",\r\n      \"Syrc\",\r\n      \"Tagalog\",\r\n      \"Tglg\",\r\n      \"Tagbanwa\",\r\n      \"Tagb\",\r\n      \"Tai_Le\",\r\n      \"Tale\",\r\n      \"Tai_Tham\",\r\n      \"Lana\",\r\n      \"Tai_Viet\",\r\n      \"Tavt\",\r\n      \"Takri\",\r\n      \"Takr\",\r\n      \"Tamil\",\r\n      \"Taml\",\r\n      \"Tangut\",\r\n      \"Tang\",\r\n      \"Telugu\",\r\n      \"Telu\",\r\n      \"Thaana\",\r\n      \"Thaa\",\r\n      \"Thai\",\r\n      \"Tibetan\",\r\n      \"Tibt\",\r\n      \"Tifinagh\",\r\n      \"Tfng\",\r\n      \"Tirhuta\",\r\n      \"Tirh\",\r\n      \"Ugaritic\",\r\n      \"Ugar\",\r\n      \"Vai\",\r\n      \"Vaii\",\r\n      \"Warang_Citi\",\r\n      \"Wara\",\r\n      \"Yi\",\r\n      \"Yiii\",\r\n      \"Zanabazar_Square\",\r\n      \"Zanb\"\r\n    ]\r\n  };\r\n  Array.prototype.push.apply(data.$LONE, data.General_Category);\r\n  data.gc = data.General_Category;\r\n  data.sc = data.Script_Extensions = data.scx = data.Script;\r\n\r\n  var pp$9 = Parser.prototype;\r\n\r\n  var RegExpValidationState = function RegExpValidationState(parser) {\r\n    this.parser = parser;\r\n    this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\r\n    this.source = \"\";\r\n    this.flags = \"\";\r\n    this.start = 0;\r\n    this.switchU = false;\r\n    this.switchN = false;\r\n    this.pos = 0;\r\n    this.lastIntValue = 0;\r\n    this.lastStringValue = \"\";\r\n    this.lastAssertionIsQuantifiable = false;\r\n    this.numCapturingParens = 0;\r\n    this.maxBackReference = 0;\r\n    this.groupNames = [];\r\n    this.backReferenceNames = [];\r\n  };\r\n\r\n  RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\r\n    var unicode = flags.indexOf(\"u\") !== -1;\r\n    this.start = start | 0;\r\n    this.source = pattern + \"\";\r\n    this.flags = flags;\r\n    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\r\n    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\r\n  };\r\n\r\n  RegExpValidationState.prototype.raise = function raise (message) {\r\n    this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\r\n  };\r\n\r\n  // If u flag is given, this returns the code point at the index (it combines a surrogate pair).\r\n  // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\r\n  RegExpValidationState.prototype.at = function at (i) {\r\n    var s = this.source;\r\n    var l = s.length;\r\n    if (i >= l) {\r\n      return -1\r\n    }\r\n    var c = s.charCodeAt(i);\r\n    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\r\n      return c\r\n    }\r\n    return (c << 10) + s.charCodeAt(i + 1) - 0x35FDC00\r\n  };\r\n\r\n  RegExpValidationState.prototype.nextIndex = function nextIndex (i) {\r\n    var s = this.source;\r\n    var l = s.length;\r\n    if (i >= l) {\r\n      return l\r\n    }\r\n    var c = s.charCodeAt(i);\r\n    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\r\n      return i + 1\r\n    }\r\n    return i + 2\r\n  };\r\n\r\n  RegExpValidationState.prototype.current = function current () {\r\n    return this.at(this.pos)\r\n  };\r\n\r\n  RegExpValidationState.prototype.lookahead = function lookahead () {\r\n    return this.at(this.nextIndex(this.pos))\r\n  };\r\n\r\n  RegExpValidationState.prototype.advance = function advance () {\r\n    this.pos = this.nextIndex(this.pos);\r\n  };\r\n\r\n  RegExpValidationState.prototype.eat = function eat (ch) {\r\n    if (this.current() === ch) {\r\n      this.advance();\r\n      return true\r\n    }\r\n    return false\r\n  };\r\n\r\n  function codePointToString$1(ch) {\r\n    if (ch <= 0xFFFF) { return String.fromCharCode(ch) }\r\n    ch -= 0x10000;\r\n    return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)\r\n  }\r\n\r\n  /**\r\n   * Validate the flags part of a given RegExpLiteral.\r\n   *\r\n   * @param {RegExpValidationState} state The state to validate RegExp.\r\n   * @returns {void}\r\n   */\r\n  pp$9.validateRegExpFlags = function(state) {\r\n    var this$1 = this;\r\n\r\n    var validFlags = state.validFlags;\r\n    var flags = state.flags;\r\n\r\n    for (var i = 0; i < flags.length; i++) {\r\n      var flag = flags.charAt(i);\r\n      if (validFlags.indexOf(flag) === -1) {\r\n        this$1.raise(state.start, \"Invalid regular expression flag\");\r\n      }\r\n      if (flags.indexOf(flag, i + 1) > -1) {\r\n        this$1.raise(state.start, \"Duplicate regular expression flag\");\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Validate the pattern part of a given RegExpLiteral.\r\n   *\r\n   * @param {RegExpValidationState} state The state to validate RegExp.\r\n   * @returns {void}\r\n   */\r\n  pp$9.validateRegExpPattern = function(state) {\r\n    this.regexp_pattern(state);\r\n\r\n    // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\r\n    // parsing contains a |GroupName|, reparse with the goal symbol\r\n    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\r\n    // exception if _P_ did not conform to the grammar, if any elements of _P_\r\n    // were not matched by the parse, or if any Early Error conditions exist.\r\n    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\r\n      state.switchN = true;\r\n      this.regexp_pattern(state);\r\n    }\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\r\n  pp$9.regexp_pattern = function(state) {\r\n    state.pos = 0;\r\n    state.lastIntValue = 0;\r\n    state.lastStringValue = \"\";\r\n    state.lastAssertionIsQuantifiable = false;\r\n    state.numCapturingParens = 0;\r\n    state.maxBackReference = 0;\r\n    state.groupNames.length = 0;\r\n    state.backReferenceNames.length = 0;\r\n\r\n    this.regexp_disjunction(state);\r\n\r\n    if (state.pos !== state.source.length) {\r\n      // Make the same messages as V8.\r\n      if (state.eat(0x29 /* ) */)) {\r\n        state.raise(\"Unmatched ')'\");\r\n      }\r\n      if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {\r\n        state.raise(\"Lone quantifier brackets\");\r\n      }\r\n    }\r\n    if (state.maxBackReference > state.numCapturingParens) {\r\n      state.raise(\"Invalid escape\");\r\n    }\r\n    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\r\n      var name = list[i];\r\n\r\n      if (state.groupNames.indexOf(name) === -1) {\r\n        state.raise(\"Invalid named capture referenced\");\r\n      }\r\n    }\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\r\n  pp$9.regexp_disjunction = function(state) {\r\n    var this$1 = this;\r\n\r\n    this.regexp_alternative(state);\r\n    while (state.eat(0x7C /* | */)) {\r\n      this$1.regexp_alternative(state);\r\n    }\r\n\r\n    // Make the same message as V8.\r\n    if (this.regexp_eatQuantifier(state, true)) {\r\n      state.raise(\"Nothing to repeat\");\r\n    }\r\n    if (state.eat(0x7B /* { */)) {\r\n      state.raise(\"Lone quantifier brackets\");\r\n    }\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\r\n  pp$9.regexp_alternative = function(state) {\r\n    while (state.pos < state.source.length && this.regexp_eatTerm(state))\r\n      {  }\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\r\n  pp$9.regexp_eatTerm = function(state) {\r\n    if (this.regexp_eatAssertion(state)) {\r\n      // Handle `QuantifiableAssertion Quantifier` alternative.\r\n      // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\r\n      // is a QuantifiableAssertion.\r\n      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\r\n        // Make the same message as V8.\r\n        if (state.switchU) {\r\n          state.raise(\"Invalid quantifier\");\r\n        }\r\n      }\r\n      return true\r\n    }\r\n\r\n    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\r\n      this.regexp_eatQuantifier(state);\r\n      return true\r\n    }\r\n\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\r\n  pp$9.regexp_eatAssertion = function(state) {\r\n    var start = state.pos;\r\n    state.lastAssertionIsQuantifiable = false;\r\n\r\n    // ^, $\r\n    if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {\r\n      return true\r\n    }\r\n\r\n    // \\b \\B\r\n    if (state.eat(0x5C /* \\ */)) {\r\n      if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {\r\n        return true\r\n      }\r\n      state.pos = start;\r\n    }\r\n\r\n    // Lookahead / Lookbehind\r\n    if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {\r\n      var lookbehind = false;\r\n      if (this.options.ecmaVersion >= 9) {\r\n        lookbehind = state.eat(0x3C /* < */);\r\n      }\r\n      if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {\r\n        this.regexp_disjunction(state);\r\n        if (!state.eat(0x29 /* ) */)) {\r\n          state.raise(\"Unterminated group\");\r\n        }\r\n        state.lastAssertionIsQuantifiable = !lookbehind;\r\n        return true\r\n      }\r\n    }\r\n\r\n    state.pos = start;\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\r\n  pp$9.regexp_eatQuantifier = function(state, noError) {\r\n    if ( noError === void 0 ) noError = false;\r\n\r\n    if (this.regexp_eatQuantifierPrefix(state, noError)) {\r\n      state.eat(0x3F /* ? */);\r\n      return true\r\n    }\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\r\n  pp$9.regexp_eatQuantifierPrefix = function(state, noError) {\r\n    return (\r\n      state.eat(0x2A /* * */) ||\r\n      state.eat(0x2B /* + */) ||\r\n      state.eat(0x3F /* ? */) ||\r\n      this.regexp_eatBracedQuantifier(state, noError)\r\n    )\r\n  };\r\n  pp$9.regexp_eatBracedQuantifier = function(state, noError) {\r\n    var start = state.pos;\r\n    if (state.eat(0x7B /* { */)) {\r\n      var min = 0, max = -1;\r\n      if (this.regexp_eatDecimalDigits(state)) {\r\n        min = state.lastIntValue;\r\n        if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {\r\n          max = state.lastIntValue;\r\n        }\r\n        if (state.eat(0x7D /* } */)) {\r\n          // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\r\n          if (max !== -1 && max < min && !noError) {\r\n            state.raise(\"numbers out of order in {} quantifier\");\r\n          }\r\n          return true\r\n        }\r\n      }\r\n      if (state.switchU && !noError) {\r\n        state.raise(\"Incomplete quantifier\");\r\n      }\r\n      state.pos = start;\r\n    }\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\r\n  pp$9.regexp_eatAtom = function(state) {\r\n    return (\r\n      this.regexp_eatPatternCharacters(state) ||\r\n      state.eat(0x2E /* . */) ||\r\n      this.regexp_eatReverseSolidusAtomEscape(state) ||\r\n      this.regexp_eatCharacterClass(state) ||\r\n      this.regexp_eatUncapturingGroup(state) ||\r\n      this.regexp_eatCapturingGroup(state)\r\n    )\r\n  };\r\n  pp$9.regexp_eatReverseSolidusAtomEscape = function(state) {\r\n    var start = state.pos;\r\n    if (state.eat(0x5C /* \\ */)) {\r\n      if (this.regexp_eatAtomEscape(state)) {\r\n        return true\r\n      }\r\n      state.pos = start;\r\n    }\r\n    return false\r\n  };\r\n  pp$9.regexp_eatUncapturingGroup = function(state) {\r\n    var start = state.pos;\r\n    if (state.eat(0x28 /* ( */)) {\r\n      if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {\r\n        this.regexp_disjunction(state);\r\n        if (state.eat(0x29 /* ) */)) {\r\n          return true\r\n        }\r\n        state.raise(\"Unterminated group\");\r\n      }\r\n      state.pos = start;\r\n    }\r\n    return false\r\n  };\r\n  pp$9.regexp_eatCapturingGroup = function(state) {\r\n    if (state.eat(0x28 /* ( */)) {\r\n      if (this.options.ecmaVersion >= 9) {\r\n        this.regexp_groupSpecifier(state);\r\n      } else if (state.current() === 0x3F /* ? */) {\r\n        state.raise(\"Invalid group\");\r\n      }\r\n      this.regexp_disjunction(state);\r\n      if (state.eat(0x29 /* ) */)) {\r\n        state.numCapturingParens += 1;\r\n        return true\r\n      }\r\n      state.raise(\"Unterminated group\");\r\n    }\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\r\n  pp$9.regexp_eatExtendedAtom = function(state) {\r\n    return (\r\n      state.eat(0x2E /* . */) ||\r\n      this.regexp_eatReverseSolidusAtomEscape(state) ||\r\n      this.regexp_eatCharacterClass(state) ||\r\n      this.regexp_eatUncapturingGroup(state) ||\r\n      this.regexp_eatCapturingGroup(state) ||\r\n      this.regexp_eatInvalidBracedQuantifier(state) ||\r\n      this.regexp_eatExtendedPatternCharacter(state)\r\n    )\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\r\n  pp$9.regexp_eatInvalidBracedQuantifier = function(state) {\r\n    if (this.regexp_eatBracedQuantifier(state, true)) {\r\n      state.raise(\"Nothing to repeat\");\r\n    }\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\r\n  pp$9.regexp_eatSyntaxCharacter = function(state) {\r\n    var ch = state.current();\r\n    if (isSyntaxCharacter(ch)) {\r\n      state.lastIntValue = ch;\r\n      state.advance();\r\n      return true\r\n    }\r\n    return false\r\n  };\r\n  function isSyntaxCharacter(ch) {\r\n    return (\r\n      ch === 0x24 /* $ */ ||\r\n      ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||\r\n      ch === 0x2E /* . */ ||\r\n      ch === 0x3F /* ? */ ||\r\n      ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||\r\n      ch >= 0x7B /* { */ && ch <= 0x7D /* } */\r\n    )\r\n  }\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\r\n  // But eat eager.\r\n  pp$9.regexp_eatPatternCharacters = function(state) {\r\n    var start = state.pos;\r\n    var ch = 0;\r\n    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\r\n      state.advance();\r\n    }\r\n    return state.pos !== start\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\r\n  pp$9.regexp_eatExtendedPatternCharacter = function(state) {\r\n    var ch = state.current();\r\n    if (\r\n      ch !== -1 &&\r\n      ch !== 0x24 /* $ */ &&\r\n      !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&\r\n      ch !== 0x2E /* . */ &&\r\n      ch !== 0x3F /* ? */ &&\r\n      ch !== 0x5B /* [ */ &&\r\n      ch !== 0x5E /* ^ */ &&\r\n      ch !== 0x7C /* | */\r\n    ) {\r\n      state.advance();\r\n      return true\r\n    }\r\n    return false\r\n  };\r\n\r\n  // GroupSpecifier[U] ::\r\n  //   [empty]\r\n  //   `?` GroupName[?U]\r\n  pp$9.regexp_groupSpecifier = function(state) {\r\n    if (state.eat(0x3F /* ? */)) {\r\n      if (this.regexp_eatGroupName(state)) {\r\n        if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\r\n          state.raise(\"Duplicate capture group name\");\r\n        }\r\n        state.groupNames.push(state.lastStringValue);\r\n        return\r\n      }\r\n      state.raise(\"Invalid group\");\r\n    }\r\n  };\r\n\r\n  // GroupName[U] ::\r\n  //   `<` RegExpIdentifierName[?U] `>`\r\n  // Note: this updates `state.lastStringValue` property with the eaten name.\r\n  pp$9.regexp_eatGroupName = function(state) {\r\n    state.lastStringValue = \"\";\r\n    if (state.eat(0x3C /* < */)) {\r\n      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {\r\n        return true\r\n      }\r\n      state.raise(\"Invalid capture group name\");\r\n    }\r\n    return false\r\n  };\r\n\r\n  // RegExpIdentifierName[U] ::\r\n  //   RegExpIdentifierStart[?U]\r\n  //   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]\r\n  // Note: this updates `state.lastStringValue` property with the eaten name.\r\n  pp$9.regexp_eatRegExpIdentifierName = function(state) {\r\n    state.lastStringValue = \"\";\r\n    if (this.regexp_eatRegExpIdentifierStart(state)) {\r\n      state.lastStringValue += codePointToString$1(state.lastIntValue);\r\n      while (this.regexp_eatRegExpIdentifierPart(state)) {\r\n        state.lastStringValue += codePointToString$1(state.lastIntValue);\r\n      }\r\n      return true\r\n    }\r\n    return false\r\n  };\r\n\r\n  // RegExpIdentifierStart[U] ::\r\n  //   UnicodeIDStart\r\n  //   `$`\r\n  //   `_`\r\n  //   `\\` RegExpUnicodeEscapeSequence[?U]\r\n  pp$9.regexp_eatRegExpIdentifierStart = function(state) {\r\n    var start = state.pos;\r\n    var ch = state.current();\r\n    state.advance();\r\n\r\n    if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\r\n      ch = state.lastIntValue;\r\n    }\r\n    if (isRegExpIdentifierStart(ch)) {\r\n      state.lastIntValue = ch;\r\n      return true\r\n    }\r\n\r\n    state.pos = start;\r\n    return false\r\n  };\r\n  function isRegExpIdentifierStart(ch) {\r\n    return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */\r\n  }\r\n\r\n  // RegExpIdentifierPart[U] ::\r\n  //   UnicodeIDContinue\r\n  //   `$`\r\n  //   `_`\r\n  //   `\\` RegExpUnicodeEscapeSequence[?U]\r\n  //   <ZWNJ>\r\n  //   <ZWJ>\r\n  pp$9.regexp_eatRegExpIdentifierPart = function(state) {\r\n    var start = state.pos;\r\n    var ch = state.current();\r\n    state.advance();\r\n\r\n    if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\r\n      ch = state.lastIntValue;\r\n    }\r\n    if (isRegExpIdentifierPart(ch)) {\r\n      state.lastIntValue = ch;\r\n      return true\r\n    }\r\n\r\n    state.pos = start;\r\n    return false\r\n  };\r\n  function isRegExpIdentifierPart(ch) {\r\n    return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */\r\n  }\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\r\n  pp$9.regexp_eatAtomEscape = function(state) {\r\n    if (\r\n      this.regexp_eatBackReference(state) ||\r\n      this.regexp_eatCharacterClassEscape(state) ||\r\n      this.regexp_eatCharacterEscape(state) ||\r\n      (state.switchN && this.regexp_eatKGroupName(state))\r\n    ) {\r\n      return true\r\n    }\r\n    if (state.switchU) {\r\n      // Make the same message as V8.\r\n      if (state.current() === 0x63 /* c */) {\r\n        state.raise(\"Invalid unicode escape\");\r\n      }\r\n      state.raise(\"Invalid escape\");\r\n    }\r\n    return false\r\n  };\r\n  pp$9.regexp_eatBackReference = function(state) {\r\n    var start = state.pos;\r\n    if (this.regexp_eatDecimalEscape(state)) {\r\n      var n = state.lastIntValue;\r\n      if (state.switchU) {\r\n        // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\r\n        if (n > state.maxBackReference) {\r\n          state.maxBackReference = n;\r\n        }\r\n        return true\r\n      }\r\n      if (n <= state.numCapturingParens) {\r\n        return true\r\n      }\r\n      state.pos = start;\r\n    }\r\n    return false\r\n  };\r\n  pp$9.regexp_eatKGroupName = function(state) {\r\n    if (state.eat(0x6B /* k */)) {\r\n      if (this.regexp_eatGroupName(state)) {\r\n        state.backReferenceNames.push(state.lastStringValue);\r\n        return true\r\n      }\r\n      state.raise(\"Invalid named reference\");\r\n    }\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\r\n  pp$9.regexp_eatCharacterEscape = function(state) {\r\n    return (\r\n      this.regexp_eatControlEscape(state) ||\r\n      this.regexp_eatCControlLetter(state) ||\r\n      this.regexp_eatZero(state) ||\r\n      this.regexp_eatHexEscapeSequence(state) ||\r\n      this.regexp_eatRegExpUnicodeEscapeSequence(state) ||\r\n      (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\r\n      this.regexp_eatIdentityEscape(state)\r\n    )\r\n  };\r\n  pp$9.regexp_eatCControlLetter = function(state) {\r\n    var start = state.pos;\r\n    if (state.eat(0x63 /* c */)) {\r\n      if (this.regexp_eatControlLetter(state)) {\r\n        return true\r\n      }\r\n      state.pos = start;\r\n    }\r\n    return false\r\n  };\r\n  pp$9.regexp_eatZero = function(state) {\r\n    if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {\r\n      state.lastIntValue = 0;\r\n      state.advance();\r\n      return true\r\n    }\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\r\n  pp$9.regexp_eatControlEscape = function(state) {\r\n    var ch = state.current();\r\n    if (ch === 0x74 /* t */) {\r\n      state.lastIntValue = 0x09; /* \\t */\r\n      state.advance();\r\n      return true\r\n    }\r\n    if (ch === 0x6E /* n */) {\r\n      state.lastIntValue = 0x0A; /* \\n */\r\n      state.advance();\r\n      return true\r\n    }\r\n    if (ch === 0x76 /* v */) {\r\n      state.lastIntValue = 0x0B; /* \\v */\r\n      state.advance();\r\n      return true\r\n    }\r\n    if (ch === 0x66 /* f */) {\r\n      state.lastIntValue = 0x0C; /* \\f */\r\n      state.advance();\r\n      return true\r\n    }\r\n    if (ch === 0x72 /* r */) {\r\n      state.lastIntValue = 0x0D; /* \\r */\r\n      state.advance();\r\n      return true\r\n    }\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\r\n  pp$9.regexp_eatControlLetter = function(state) {\r\n    var ch = state.current();\r\n    if (isControlLetter(ch)) {\r\n      state.lastIntValue = ch % 0x20;\r\n      state.advance();\r\n      return true\r\n    }\r\n    return false\r\n  };\r\n  function isControlLetter(ch) {\r\n    return (\r\n      (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||\r\n      (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)\r\n    )\r\n  }\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\r\n  pp$9.regexp_eatRegExpUnicodeEscapeSequence = function(state) {\r\n    var start = state.pos;\r\n\r\n    if (state.eat(0x75 /* u */)) {\r\n      if (this.regexp_eatFixedHexDigits(state, 4)) {\r\n        var lead = state.lastIntValue;\r\n        if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {\r\n          var leadSurrogateEnd = state.pos;\r\n          if (state.eat(0x5C /* \\ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {\r\n            var trail = state.lastIntValue;\r\n            if (trail >= 0xDC00 && trail <= 0xDFFF) {\r\n              state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\r\n              return true\r\n            }\r\n          }\r\n          state.pos = leadSurrogateEnd;\r\n          state.lastIntValue = lead;\r\n        }\r\n        return true\r\n      }\r\n      if (\r\n        state.switchU &&\r\n        state.eat(0x7B /* { */) &&\r\n        this.regexp_eatHexDigits(state) &&\r\n        state.eat(0x7D /* } */) &&\r\n        isValidUnicode(state.lastIntValue)\r\n      ) {\r\n        return true\r\n      }\r\n      if (state.switchU) {\r\n        state.raise(\"Invalid unicode escape\");\r\n      }\r\n      state.pos = start;\r\n    }\r\n\r\n    return false\r\n  };\r\n  function isValidUnicode(ch) {\r\n    return ch >= 0 && ch <= 0x10FFFF\r\n  }\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\r\n  pp$9.regexp_eatIdentityEscape = function(state) {\r\n    if (state.switchU) {\r\n      if (this.regexp_eatSyntaxCharacter(state)) {\r\n        return true\r\n      }\r\n      if (state.eat(0x2F /* / */)) {\r\n        state.lastIntValue = 0x2F; /* / */\r\n        return true\r\n      }\r\n      return false\r\n    }\r\n\r\n    var ch = state.current();\r\n    if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {\r\n      state.lastIntValue = ch;\r\n      state.advance();\r\n      return true\r\n    }\r\n\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\r\n  pp$9.regexp_eatDecimalEscape = function(state) {\r\n    state.lastIntValue = 0;\r\n    var ch = state.current();\r\n    if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {\r\n      do {\r\n        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\r\n        state.advance();\r\n      } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)\r\n      return true\r\n    }\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\r\n  pp$9.regexp_eatCharacterClassEscape = function(state) {\r\n    var ch = state.current();\r\n\r\n    if (isCharacterClassEscape(ch)) {\r\n      state.lastIntValue = -1;\r\n      state.advance();\r\n      return true\r\n    }\r\n\r\n    if (\r\n      state.switchU &&\r\n      this.options.ecmaVersion >= 9 &&\r\n      (ch === 0x50 /* P */ || ch === 0x70 /* p */)\r\n    ) {\r\n      state.lastIntValue = -1;\r\n      state.advance();\r\n      if (\r\n        state.eat(0x7B /* { */) &&\r\n        this.regexp_eatUnicodePropertyValueExpression(state) &&\r\n        state.eat(0x7D /* } */)\r\n      ) {\r\n        return true\r\n      }\r\n      state.raise(\"Invalid property name\");\r\n    }\r\n\r\n    return false\r\n  };\r\n  function isCharacterClassEscape(ch) {\r\n    return (\r\n      ch === 0x64 /* d */ ||\r\n      ch === 0x44 /* D */ ||\r\n      ch === 0x73 /* s */ ||\r\n      ch === 0x53 /* S */ ||\r\n      ch === 0x77 /* w */ ||\r\n      ch === 0x57 /* W */\r\n    )\r\n  }\r\n\r\n  // UnicodePropertyValueExpression ::\r\n  //   UnicodePropertyName `=` UnicodePropertyValue\r\n  //   LoneUnicodePropertyNameOrValue\r\n  pp$9.regexp_eatUnicodePropertyValueExpression = function(state) {\r\n    var start = state.pos;\r\n\r\n    // UnicodePropertyName `=` UnicodePropertyValue\r\n    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {\r\n      var name = state.lastStringValue;\r\n      if (this.regexp_eatUnicodePropertyValue(state)) {\r\n        var value = state.lastStringValue;\r\n        this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\r\n        return true\r\n      }\r\n    }\r\n    state.pos = start;\r\n\r\n    // LoneUnicodePropertyNameOrValue\r\n    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\r\n      var nameOrValue = state.lastStringValue;\r\n      this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\r\n      return true\r\n    }\r\n    return false\r\n  };\r\n  pp$9.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\r\n    if (!data.hasOwnProperty(name) || data[name].indexOf(value) === -1) {\r\n      state.raise(\"Invalid property name\");\r\n    }\r\n  };\r\n  pp$9.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\r\n    if (data.$LONE.indexOf(nameOrValue) === -1) {\r\n      state.raise(\"Invalid property name\");\r\n    }\r\n  };\r\n\r\n  // UnicodePropertyName ::\r\n  //   UnicodePropertyNameCharacters\r\n  pp$9.regexp_eatUnicodePropertyName = function(state) {\r\n    var ch = 0;\r\n    state.lastStringValue = \"\";\r\n    while (isUnicodePropertyNameCharacter(ch = state.current())) {\r\n      state.lastStringValue += codePointToString$1(ch);\r\n      state.advance();\r\n    }\r\n    return state.lastStringValue !== \"\"\r\n  };\r\n  function isUnicodePropertyNameCharacter(ch) {\r\n    return isControlLetter(ch) || ch === 0x5F /* _ */\r\n  }\r\n\r\n  // UnicodePropertyValue ::\r\n  //   UnicodePropertyValueCharacters\r\n  pp$9.regexp_eatUnicodePropertyValue = function(state) {\r\n    var ch = 0;\r\n    state.lastStringValue = \"\";\r\n    while (isUnicodePropertyValueCharacter(ch = state.current())) {\r\n      state.lastStringValue += codePointToString$1(ch);\r\n      state.advance();\r\n    }\r\n    return state.lastStringValue !== \"\"\r\n  };\r\n  function isUnicodePropertyValueCharacter(ch) {\r\n    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\r\n  }\r\n\r\n  // LoneUnicodePropertyNameOrValue ::\r\n  //   UnicodePropertyValueCharacters\r\n  pp$9.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\r\n    return this.regexp_eatUnicodePropertyValue(state)\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\r\n  pp$9.regexp_eatCharacterClass = function(state) {\r\n    if (state.eat(0x5B /* [ */)) {\r\n      state.eat(0x5E /* ^ */);\r\n      this.regexp_classRanges(state);\r\n      if (state.eat(0x5D /* [ */)) {\r\n        return true\r\n      }\r\n      // Unreachable since it threw \"unterminated regular expression\" error before.\r\n      state.raise(\"Unterminated character class\");\r\n    }\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\r\n  pp$9.regexp_classRanges = function(state) {\r\n    var this$1 = this;\r\n\r\n    while (this.regexp_eatClassAtom(state)) {\r\n      var left = state.lastIntValue;\r\n      if (state.eat(0x2D /* - */) && this$1.regexp_eatClassAtom(state)) {\r\n        var right = state.lastIntValue;\r\n        if (state.switchU && (left === -1 || right === -1)) {\r\n          state.raise(\"Invalid character class\");\r\n        }\r\n        if (left !== -1 && right !== -1 && left > right) {\r\n          state.raise(\"Range out of order in character class\");\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\r\n  pp$9.regexp_eatClassAtom = function(state) {\r\n    var start = state.pos;\r\n\r\n    if (state.eat(0x5C /* \\ */)) {\r\n      if (this.regexp_eatClassEscape(state)) {\r\n        return true\r\n      }\r\n      if (state.switchU) {\r\n        // Make the same message as V8.\r\n        var ch$1 = state.current();\r\n        if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {\r\n          state.raise(\"Invalid class escape\");\r\n        }\r\n        state.raise(\"Invalid escape\");\r\n      }\r\n      state.pos = start;\r\n    }\r\n\r\n    var ch = state.current();\r\n    if (ch !== 0x5D /* [ */) {\r\n      state.lastIntValue = ch;\r\n      state.advance();\r\n      return true\r\n    }\r\n\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\r\n  pp$9.regexp_eatClassEscape = function(state) {\r\n    var start = state.pos;\r\n\r\n    if (state.eat(0x62 /* b */)) {\r\n      state.lastIntValue = 0x08; /* <BS> */\r\n      return true\r\n    }\r\n\r\n    if (state.switchU && state.eat(0x2D /* - */)) {\r\n      state.lastIntValue = 0x2D; /* - */\r\n      return true\r\n    }\r\n\r\n    if (!state.switchU && state.eat(0x63 /* c */)) {\r\n      if (this.regexp_eatClassControlLetter(state)) {\r\n        return true\r\n      }\r\n      state.pos = start;\r\n    }\r\n\r\n    return (\r\n      this.regexp_eatCharacterClassEscape(state) ||\r\n      this.regexp_eatCharacterEscape(state)\r\n    )\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\r\n  pp$9.regexp_eatClassControlLetter = function(state) {\r\n    var ch = state.current();\r\n    if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {\r\n      state.lastIntValue = ch % 0x20;\r\n      state.advance();\r\n      return true\r\n    }\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\r\n  pp$9.regexp_eatHexEscapeSequence = function(state) {\r\n    var start = state.pos;\r\n    if (state.eat(0x78 /* x */)) {\r\n      if (this.regexp_eatFixedHexDigits(state, 2)) {\r\n        return true\r\n      }\r\n      if (state.switchU) {\r\n        state.raise(\"Invalid escape\");\r\n      }\r\n      state.pos = start;\r\n    }\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\r\n  pp$9.regexp_eatDecimalDigits = function(state) {\r\n    var start = state.pos;\r\n    var ch = 0;\r\n    state.lastIntValue = 0;\r\n    while (isDecimalDigit(ch = state.current())) {\r\n      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\r\n      state.advance();\r\n    }\r\n    return state.pos !== start\r\n  };\r\n  function isDecimalDigit(ch) {\r\n    return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */\r\n  }\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\r\n  pp$9.regexp_eatHexDigits = function(state) {\r\n    var start = state.pos;\r\n    var ch = 0;\r\n    state.lastIntValue = 0;\r\n    while (isHexDigit(ch = state.current())) {\r\n      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\r\n      state.advance();\r\n    }\r\n    return state.pos !== start\r\n  };\r\n  function isHexDigit(ch) {\r\n    return (\r\n      (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||\r\n      (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||\r\n      (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)\r\n    )\r\n  }\r\n  function hexToInt(ch) {\r\n    if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {\r\n      return 10 + (ch - 0x41 /* A */)\r\n    }\r\n    if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {\r\n      return 10 + (ch - 0x61 /* a */)\r\n    }\r\n    return ch - 0x30 /* 0 */\r\n  }\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\r\n  // Allows only 0-377(octal) i.e. 0-255(decimal).\r\n  pp$9.regexp_eatLegacyOctalEscapeSequence = function(state) {\r\n    if (this.regexp_eatOctalDigit(state)) {\r\n      var n1 = state.lastIntValue;\r\n      if (this.regexp_eatOctalDigit(state)) {\r\n        var n2 = state.lastIntValue;\r\n        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\r\n          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\r\n        } else {\r\n          state.lastIntValue = n1 * 8 + n2;\r\n        }\r\n      } else {\r\n        state.lastIntValue = n1;\r\n      }\r\n      return true\r\n    }\r\n    return false\r\n  };\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\r\n  pp$9.regexp_eatOctalDigit = function(state) {\r\n    var ch = state.current();\r\n    if (isOctalDigit(ch)) {\r\n      state.lastIntValue = ch - 0x30; /* 0 */\r\n      state.advance();\r\n      return true\r\n    }\r\n    state.lastIntValue = 0;\r\n    return false\r\n  };\r\n  function isOctalDigit(ch) {\r\n    return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */\r\n  }\r\n\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\r\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\r\n  // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\r\n  pp$9.regexp_eatFixedHexDigits = function(state, length) {\r\n    var start = state.pos;\r\n    state.lastIntValue = 0;\r\n    for (var i = 0; i < length; ++i) {\r\n      var ch = state.current();\r\n      if (!isHexDigit(ch)) {\r\n        state.pos = start;\r\n        return false\r\n      }\r\n      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\r\n      state.advance();\r\n    }\r\n    return true\r\n  };\r\n\r\n  // Object type used to represent tokens. Note that normally, tokens\r\n  // simply exist as properties on the parser object. This is only\r\n  // used for the onToken callback and the external tokenizer.\r\n\r\n  var Token = function Token(p) {\r\n    this.type = p.type;\r\n    this.value = p.value;\r\n    this.start = p.start;\r\n    this.end = p.end;\r\n    if (p.options.locations)\r\n      { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\r\n    if (p.options.ranges)\r\n      { this.range = [p.start, p.end]; }\r\n  };\r\n\r\n  // ## Tokenizer\r\n\r\n  var pp$8 = Parser.prototype;\r\n\r\n  // Move to the next token\r\n\r\n  pp$8.next = function() {\r\n    if (this.options.onToken)\r\n      { this.options.onToken(new Token(this)); }\r\n\r\n    this.lastTokEnd = this.end;\r\n    this.lastTokStart = this.start;\r\n    this.lastTokEndLoc = this.endLoc;\r\n    this.lastTokStartLoc = this.startLoc;\r\n    this.nextToken();\r\n  };\r\n\r\n  pp$8.getToken = function() {\r\n    this.next();\r\n    return new Token(this)\r\n  };\r\n\r\n  // If we're in an ES6 environment, make parsers iterable\r\n  if (typeof Symbol !== \"undefined\")\r\n    { pp$8[Symbol.iterator] = function() {\r\n      var this$1 = this;\r\n\r\n      return {\r\n        next: function () {\r\n          var token = this$1.getToken();\r\n          return {\r\n            done: token.type === types.eof,\r\n            value: token\r\n          }\r\n        }\r\n      }\r\n    }; }\r\n\r\n  // Toggle strict mode. Re-reads the next number or string to please\r\n  // pedantic tests (`\"use strict\"; 010;` should fail).\r\n\r\n  pp$8.curContext = function() {\r\n    return this.context[this.context.length - 1]\r\n  };\r\n\r\n  // Read a single token, updating the parser object's token-related\r\n  // properties.\r\n\r\n  pp$8.nextToken = function() {\r\n    var curContext = this.curContext();\r\n    if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\r\n\r\n    this.start = this.pos;\r\n    if (this.options.locations) { this.startLoc = this.curPosition(); }\r\n    if (this.pos >= this.input.length) { return this.finishToken(types.eof) }\r\n\r\n    if (curContext.override) { return curContext.override(this) }\r\n    else { this.readToken(this.fullCharCodeAtPos()); }\r\n  };\r\n\r\n  pp$8.readToken = function(code) {\r\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\r\n    // identifiers, so '\\' also dispatches to that.\r\n    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\r\n      { return this.readWord() }\r\n\r\n    return this.getTokenFromCode(code)\r\n  };\r\n\r\n  pp$8.fullCharCodeAtPos = function() {\r\n    var code = this.input.charCodeAt(this.pos);\r\n    if (code <= 0xd7ff || code >= 0xe000) { return code }\r\n    var next = this.input.charCodeAt(this.pos + 1);\r\n    return (code << 10) + next - 0x35fdc00\r\n  };\r\n\r\n  pp$8.skipBlockComment = function() {\r\n    var this$1 = this;\r\n\r\n    var startLoc = this.options.onComment && this.curPosition();\r\n    var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\r\n    if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\r\n    this.pos = end + 2;\r\n    if (this.options.locations) {\r\n      lineBreakG.lastIndex = start;\r\n      var match;\r\n      while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\r\n        ++this$1.curLine;\r\n        this$1.lineStart = match.index + match[0].length;\r\n      }\r\n    }\r\n    if (this.options.onComment)\r\n      { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\r\n                             startLoc, this.curPosition()); }\r\n  };\r\n\r\n  pp$8.skipLineComment = function(startSkip) {\r\n    var this$1 = this;\r\n\r\n    var start = this.pos;\r\n    var startLoc = this.options.onComment && this.curPosition();\r\n    var ch = this.input.charCodeAt(this.pos += startSkip);\r\n    while (this.pos < this.input.length && !isNewLine(ch)) {\r\n      ch = this$1.input.charCodeAt(++this$1.pos);\r\n    }\r\n    if (this.options.onComment)\r\n      { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\r\n                             startLoc, this.curPosition()); }\r\n  };\r\n\r\n  // Called at the start of the parse and after every token. Skips\r\n  // whitespace and comments, and.\r\n\r\n  pp$8.skipSpace = function() {\r\n    var this$1 = this;\r\n\r\n    loop: while (this.pos < this.input.length) {\r\n      var ch = this$1.input.charCodeAt(this$1.pos);\r\n      switch (ch) {\r\n      case 32: case 160: // ' '\r\n        ++this$1.pos;\r\n        break\r\n      case 13:\r\n        if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {\r\n          ++this$1.pos;\r\n        }\r\n      case 10: case 8232: case 8233:\r\n        ++this$1.pos;\r\n        if (this$1.options.locations) {\r\n          ++this$1.curLine;\r\n          this$1.lineStart = this$1.pos;\r\n        }\r\n        break\r\n      case 47: // '/'\r\n        switch (this$1.input.charCodeAt(this$1.pos + 1)) {\r\n        case 42: // '*'\r\n          this$1.skipBlockComment();\r\n          break\r\n        case 47:\r\n          this$1.skipLineComment(2);\r\n          break\r\n        default:\r\n          break loop\r\n        }\r\n        break\r\n      default:\r\n        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\r\n          ++this$1.pos;\r\n        } else {\r\n          break loop\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  // Called at the end of every token. Sets `end`, `val`, and\r\n  // maintains `context` and `exprAllowed`, and skips the space after\r\n  // the token, so that the next one's `start` will point at the\r\n  // right position.\r\n\r\n  pp$8.finishToken = function(type, val) {\r\n    this.end = this.pos;\r\n    if (this.options.locations) { this.endLoc = this.curPosition(); }\r\n    var prevType = this.type;\r\n    this.type = type;\r\n    this.value = val;\r\n\r\n    this.updateContext(prevType);\r\n  };\r\n\r\n  // ### Token reading\r\n\r\n  // This is the function that is called to fetch the next token. It\r\n  // is somewhat obscure, because it works in character codes rather\r\n  // than characters, and because operator parsing has been inlined\r\n  // into it.\r\n  //\r\n  // All in the name of speed.\r\n  //\r\n  pp$8.readToken_dot = function() {\r\n    var next = this.input.charCodeAt(this.pos + 1);\r\n    if (next >= 48 && next <= 57) { return this.readNumber(true) }\r\n    var next2 = this.input.charCodeAt(this.pos + 2);\r\n    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\r\n      this.pos += 3;\r\n      return this.finishToken(types.ellipsis)\r\n    } else {\r\n      ++this.pos;\r\n      return this.finishToken(types.dot)\r\n    }\r\n  };\r\n\r\n  pp$8.readToken_slash = function() { // '/'\r\n    var next = this.input.charCodeAt(this.pos + 1);\r\n    if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\r\n    if (next === 61) { return this.finishOp(types.assign, 2) }\r\n    return this.finishOp(types.slash, 1)\r\n  };\r\n\r\n  pp$8.readToken_mult_modulo_exp = function(code) { // '%*'\r\n    var next = this.input.charCodeAt(this.pos + 1);\r\n    var size = 1;\r\n    var tokentype = code === 42 ? types.star : types.modulo;\r\n\r\n    // exponentiation operator ** and **=\r\n    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\r\n      ++size;\r\n      tokentype = types.starstar;\r\n      next = this.input.charCodeAt(this.pos + 2);\r\n    }\r\n\r\n    if (next === 61) { return this.finishOp(types.assign, size + 1) }\r\n    return this.finishOp(tokentype, size)\r\n  };\r\n\r\n  pp$8.readToken_pipe_amp = function(code) { // '|&'\r\n    var next = this.input.charCodeAt(this.pos + 1);\r\n    if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }\r\n    if (next === 61) { return this.finishOp(types.assign, 2) }\r\n    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)\r\n  };\r\n\r\n  pp$8.readToken_caret = function() { // '^'\r\n    var next = this.input.charCodeAt(this.pos + 1);\r\n    if (next === 61) { return this.finishOp(types.assign, 2) }\r\n    return this.finishOp(types.bitwiseXOR, 1)\r\n  };\r\n\r\n  pp$8.readToken_plus_min = function(code) { // '+-'\r\n    var next = this.input.charCodeAt(this.pos + 1);\r\n    if (next === code) {\r\n      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\r\n          (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\r\n        // A `-->` line comment\r\n        this.skipLineComment(3);\r\n        this.skipSpace();\r\n        return this.nextToken()\r\n      }\r\n      return this.finishOp(types.incDec, 2)\r\n    }\r\n    if (next === 61) { return this.finishOp(types.assign, 2) }\r\n    return this.finishOp(types.plusMin, 1)\r\n  };\r\n\r\n  pp$8.readToken_lt_gt = function(code) { // '<>'\r\n    var next = this.input.charCodeAt(this.pos + 1);\r\n    var size = 1;\r\n    if (next === code) {\r\n      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\r\n      if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }\r\n      return this.finishOp(types.bitShift, size)\r\n    }\r\n    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\r\n        this.input.charCodeAt(this.pos + 3) === 45) {\r\n      // `<!--`, an XML-style comment that should be interpreted as a line comment\r\n      this.skipLineComment(4);\r\n      this.skipSpace();\r\n      return this.nextToken()\r\n    }\r\n    if (next === 61) { size = 2; }\r\n    return this.finishOp(types.relational, size)\r\n  };\r\n\r\n  pp$8.readToken_eq_excl = function(code) { // '=!'\r\n    var next = this.input.charCodeAt(this.pos + 1);\r\n    if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\r\n    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\r\n      this.pos += 2;\r\n      return this.finishToken(types.arrow)\r\n    }\r\n    return this.finishOp(code === 61 ? types.eq : types.prefix, 1)\r\n  };\r\n\r\n  pp$8.getTokenFromCode = function(code) {\r\n    switch (code) {\r\n    // The interpretation of a dot depends on whether it is followed\r\n    // by a digit or another two dots.\r\n    case 46: // '.'\r\n      return this.readToken_dot()\r\n\r\n    // Punctuation tokens.\r\n    case 40: ++this.pos; return this.finishToken(types.parenL)\r\n    case 41: ++this.pos; return this.finishToken(types.parenR)\r\n    case 59: ++this.pos; return this.finishToken(types.semi)\r\n    case 44: ++this.pos; return this.finishToken(types.comma)\r\n    case 91: ++this.pos; return this.finishToken(types.bracketL)\r\n    case 93: ++this.pos; return this.finishToken(types.bracketR)\r\n    case 123: ++this.pos; return this.finishToken(types.braceL)\r\n    case 125: ++this.pos; return this.finishToken(types.braceR)\r\n    case 58: ++this.pos; return this.finishToken(types.colon)\r\n    case 63: ++this.pos; return this.finishToken(types.question)\r\n\r\n    case 96: // '`'\r\n      if (this.options.ecmaVersion < 6) { break }\r\n      ++this.pos;\r\n      return this.finishToken(types.backQuote)\r\n\r\n    case 48: // '0'\r\n      var next = this.input.charCodeAt(this.pos + 1);\r\n      if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\r\n      if (this.options.ecmaVersion >= 6) {\r\n        if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\r\n        if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\r\n      }\r\n\r\n    // Anything else beginning with a digit is an integer, octal\r\n    // number, or float.\r\n    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\r\n      return this.readNumber(false)\r\n\r\n    // Quotes produce strings.\r\n    case 34: case 39: // '\"', \"'\"\r\n      return this.readString(code)\r\n\r\n    // Operators are parsed inline in tiny state machines. '=' (61) is\r\n    // often referred to. `finishOp` simply skips the amount of\r\n    // characters it is given as second argument, and returns a token\r\n    // of the type given by its first argument.\r\n\r\n    case 47: // '/'\r\n      return this.readToken_slash()\r\n\r\n    case 37: case 42: // '%*'\r\n      return this.readToken_mult_modulo_exp(code)\r\n\r\n    case 124: case 38: // '|&'\r\n      return this.readToken_pipe_amp(code)\r\n\r\n    case 94: // '^'\r\n      return this.readToken_caret()\r\n\r\n    case 43: case 45: // '+-'\r\n      return this.readToken_plus_min(code)\r\n\r\n    case 60: case 62: // '<>'\r\n      return this.readToken_lt_gt(code)\r\n\r\n    case 61: case 33: // '=!'\r\n      return this.readToken_eq_excl(code)\r\n\r\n    case 126: // '~'\r\n      return this.finishOp(types.prefix, 1)\r\n    }\r\n\r\n    this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\r\n  };\r\n\r\n  pp$8.finishOp = function(type, size) {\r\n    var str = this.input.slice(this.pos, this.pos + size);\r\n    this.pos += size;\r\n    return this.finishToken(type, str)\r\n  };\r\n\r\n  pp$8.readRegexp = function() {\r\n    var this$1 = this;\r\n\r\n    var escaped, inClass, start = this.pos;\r\n    for (;;) {\r\n      if (this$1.pos >= this$1.input.length) { this$1.raise(start, \"Unterminated regular expression\"); }\r\n      var ch = this$1.input.charAt(this$1.pos);\r\n      if (lineBreak.test(ch)) { this$1.raise(start, \"Unterminated regular expression\"); }\r\n      if (!escaped) {\r\n        if (ch === \"[\") { inClass = true; }\r\n        else if (ch === \"]\" && inClass) { inClass = false; }\r\n        else if (ch === \"/\" && !inClass) { break }\r\n        escaped = ch === \"\\\\\";\r\n      } else { escaped = false; }\r\n      ++this$1.pos;\r\n    }\r\n    var pattern = this.input.slice(start, this.pos);\r\n    ++this.pos;\r\n    var flagsStart = this.pos;\r\n    var flags = this.readWord1();\r\n    if (this.containsEsc) { this.unexpected(flagsStart); }\r\n\r\n    // Validate pattern\r\n    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\r\n    state.reset(start, pattern, flags);\r\n    this.validateRegExpFlags(state);\r\n    this.validateRegExpPattern(state);\r\n\r\n    // Create Literal#value property value.\r\n    var value = null;\r\n    try {\r\n      value = new RegExp(pattern, flags);\r\n    } catch (e) {\r\n      // ESTree requires null if it failed to instantiate RegExp object.\r\n      // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\r\n    }\r\n\r\n    return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})\r\n  };\r\n\r\n  // Read an integer in the given radix. Return null if zero digits\r\n  // were read, the integer value otherwise. When `len` is given, this\r\n  // will return `null` unless the integer has exactly `len` digits.\r\n\r\n  pp$8.readInt = function(radix, len) {\r\n    var this$1 = this;\r\n\r\n    var start = this.pos, total = 0;\r\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\r\n      var code = this$1.input.charCodeAt(this$1.pos), val = (void 0);\r\n      if (code >= 97) { val = code - 97 + 10; } // a\r\n      else if (code >= 65) { val = code - 65 + 10; } // A\r\n      else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\r\n      else { val = Infinity; }\r\n      if (val >= radix) { break }\r\n      ++this$1.pos;\r\n      total = total * radix + val;\r\n    }\r\n    if (this.pos === start || len != null && this.pos - start !== len) { return null }\r\n\r\n    return total\r\n  };\r\n\r\n  pp$8.readRadixNumber = function(radix) {\r\n    this.pos += 2; // 0x\r\n    var val = this.readInt(radix);\r\n    if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\r\n    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\r\n    return this.finishToken(types.num, val)\r\n  };\r\n\r\n  // Read an integer, octal integer, or floating-point number.\r\n\r\n  pp$8.readNumber = function(startsWithDot) {\r\n    var start = this.pos;\r\n    if (!startsWithDot && this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\r\n    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\r\n    if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\r\n    if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\r\n    var next = this.input.charCodeAt(this.pos);\r\n    if (next === 46 && !octal) { // '.'\r\n      ++this.pos;\r\n      this.readInt(10);\r\n      next = this.input.charCodeAt(this.pos);\r\n    }\r\n    if ((next === 69 || next === 101) && !octal) { // 'eE'\r\n      next = this.input.charCodeAt(++this.pos);\r\n      if (next === 43 || next === 45) { ++this.pos; } // '+-'\r\n      if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\r\n    }\r\n    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\r\n\r\n    var str = this.input.slice(start, this.pos);\r\n    var val = octal ? parseInt(str, 8) : parseFloat(str);\r\n    return this.finishToken(types.num, val)\r\n  };\r\n\r\n  // Read a string value, interpreting backslash-escapes.\r\n\r\n  pp$8.readCodePoint = function() {\r\n    var ch = this.input.charCodeAt(this.pos), code;\r\n\r\n    if (ch === 123) { // '{'\r\n      if (this.options.ecmaVersion < 6) { this.unexpected(); }\r\n      var codePos = ++this.pos;\r\n      code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\r\n      ++this.pos;\r\n      if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\r\n    } else {\r\n      code = this.readHexChar(4);\r\n    }\r\n    return code\r\n  };\r\n\r\n  function codePointToString(code) {\r\n    // UTF-16 Decoding\r\n    if (code <= 0xFFFF) { return String.fromCharCode(code) }\r\n    code -= 0x10000;\r\n    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\r\n  }\r\n\r\n  pp$8.readString = function(quote) {\r\n    var this$1 = this;\r\n\r\n    var out = \"\", chunkStart = ++this.pos;\r\n    for (;;) {\r\n      if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, \"Unterminated string constant\"); }\r\n      var ch = this$1.input.charCodeAt(this$1.pos);\r\n      if (ch === quote) { break }\r\n      if (ch === 92) { // '\\'\r\n        out += this$1.input.slice(chunkStart, this$1.pos);\r\n        out += this$1.readEscapedChar(false);\r\n        chunkStart = this$1.pos;\r\n      } else {\r\n        if (isNewLine(ch, this$1.options.ecmaVersion >= 10)) { this$1.raise(this$1.start, \"Unterminated string constant\"); }\r\n        ++this$1.pos;\r\n      }\r\n    }\r\n    out += this.input.slice(chunkStart, this.pos++);\r\n    return this.finishToken(types.string, out)\r\n  };\r\n\r\n  // Reads template string tokens.\r\n\r\n  var INVALID_TEMPLATE_ESCAPE_ERROR = {};\r\n\r\n  pp$8.tryReadTemplateToken = function() {\r\n    this.inTemplateElement = true;\r\n    try {\r\n      this.readTmplToken();\r\n    } catch (err) {\r\n      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\r\n        this.readInvalidTemplateToken();\r\n      } else {\r\n        throw err\r\n      }\r\n    }\r\n\r\n    this.inTemplateElement = false;\r\n  };\r\n\r\n  pp$8.invalidStringToken = function(position, message) {\r\n    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\r\n      throw INVALID_TEMPLATE_ESCAPE_ERROR\r\n    } else {\r\n      this.raise(position, message);\r\n    }\r\n  };\r\n\r\n  pp$8.readTmplToken = function() {\r\n    var this$1 = this;\r\n\r\n    var out = \"\", chunkStart = this.pos;\r\n    for (;;) {\r\n      if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, \"Unterminated template\"); }\r\n      var ch = this$1.input.charCodeAt(this$1.pos);\r\n      if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'\r\n        if (this$1.pos === this$1.start && (this$1.type === types.template || this$1.type === types.invalidTemplate)) {\r\n          if (ch === 36) {\r\n            this$1.pos += 2;\r\n            return this$1.finishToken(types.dollarBraceL)\r\n          } else {\r\n            ++this$1.pos;\r\n            return this$1.finishToken(types.backQuote)\r\n          }\r\n        }\r\n        out += this$1.input.slice(chunkStart, this$1.pos);\r\n        return this$1.finishToken(types.template, out)\r\n      }\r\n      if (ch === 92) { // '\\'\r\n        out += this$1.input.slice(chunkStart, this$1.pos);\r\n        out += this$1.readEscapedChar(true);\r\n        chunkStart = this$1.pos;\r\n      } else if (isNewLine(ch)) {\r\n        out += this$1.input.slice(chunkStart, this$1.pos);\r\n        ++this$1.pos;\r\n        switch (ch) {\r\n        case 13:\r\n          if (this$1.input.charCodeAt(this$1.pos) === 10) { ++this$1.pos; }\r\n        case 10:\r\n          out += \"\\n\";\r\n          break\r\n        default:\r\n          out += String.fromCharCode(ch);\r\n          break\r\n        }\r\n        if (this$1.options.locations) {\r\n          ++this$1.curLine;\r\n          this$1.lineStart = this$1.pos;\r\n        }\r\n        chunkStart = this$1.pos;\r\n      } else {\r\n        ++this$1.pos;\r\n      }\r\n    }\r\n  };\r\n\r\n  // Reads a template token to search for the end, without validating any escape sequences\r\n  pp$8.readInvalidTemplateToken = function() {\r\n    var this$1 = this;\r\n\r\n    for (; this.pos < this.input.length; this.pos++) {\r\n      switch (this$1.input[this$1.pos]) {\r\n      case \"\\\\\":\r\n        ++this$1.pos;\r\n        break\r\n\r\n      case \"$\":\r\n        if (this$1.input[this$1.pos + 1] !== \"{\") {\r\n          break\r\n        }\r\n      // falls through\r\n\r\n      case \"`\":\r\n        return this$1.finishToken(types.invalidTemplate, this$1.input.slice(this$1.start, this$1.pos))\r\n\r\n      // no default\r\n      }\r\n    }\r\n    this.raise(this.start, \"Unterminated template\");\r\n  };\r\n\r\n  // Used to read escaped characters\r\n\r\n  pp$8.readEscapedChar = function(inTemplate) {\r\n    var ch = this.input.charCodeAt(++this.pos);\r\n    ++this.pos;\r\n    switch (ch) {\r\n    case 110: return \"\\n\" // 'n' -> '\\n'\r\n    case 114: return \"\\r\" // 'r' -> '\\r'\r\n    case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\r\n    case 117: return codePointToString(this.readCodePoint()) // 'u'\r\n    case 116: return \"\\t\" // 't' -> '\\t'\r\n    case 98: return \"\\b\" // 'b' -> '\\b'\r\n    case 118: return \"\\u000b\" // 'v' -> '\\u000b'\r\n    case 102: return \"\\f\" // 'f' -> '\\f'\r\n    case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\r\n    case 10: // ' \\n'\r\n      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\r\n      return \"\"\r\n    default:\r\n      if (ch >= 48 && ch <= 55) {\r\n        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\r\n        var octal = parseInt(octalStr, 8);\r\n        if (octal > 255) {\r\n          octalStr = octalStr.slice(0, -1);\r\n          octal = parseInt(octalStr, 8);\r\n        }\r\n        this.pos += octalStr.length - 1;\r\n        ch = this.input.charCodeAt(this.pos);\r\n        if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\r\n          this.invalidStringToken(\r\n            this.pos - 1 - octalStr.length,\r\n            inTemplate\r\n              ? \"Octal literal in template string\"\r\n              : \"Octal literal in strict mode\"\r\n          );\r\n        }\r\n        return String.fromCharCode(octal)\r\n      }\r\n      return String.fromCharCode(ch)\r\n    }\r\n  };\r\n\r\n  // Used to read character escape sequences ('\\x', '\\u', '\\U').\r\n\r\n  pp$8.readHexChar = function(len) {\r\n    var codePos = this.pos;\r\n    var n = this.readInt(16, len);\r\n    if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\r\n    return n\r\n  };\r\n\r\n  // Read an identifier, and return it as a string. Sets `this.containsEsc`\r\n  // to whether the word contained a '\\u' escape.\r\n  //\r\n  // Incrementally adds only escaped chars, adding other chunks as-is\r\n  // as a micro-optimization.\r\n\r\n  pp$8.readWord1 = function() {\r\n    var this$1 = this;\r\n\r\n    this.containsEsc = false;\r\n    var word = \"\", first = true, chunkStart = this.pos;\r\n    var astral = this.options.ecmaVersion >= 6;\r\n    while (this.pos < this.input.length) {\r\n      var ch = this$1.fullCharCodeAtPos();\r\n      if (isIdentifierChar(ch, astral)) {\r\n        this$1.pos += ch <= 0xffff ? 1 : 2;\r\n      } else if (ch === 92) { // \"\\\"\r\n        this$1.containsEsc = true;\r\n        word += this$1.input.slice(chunkStart, this$1.pos);\r\n        var escStart = this$1.pos;\r\n        if (this$1.input.charCodeAt(++this$1.pos) !== 117) // \"u\"\r\n          { this$1.invalidStringToken(this$1.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\r\n        ++this$1.pos;\r\n        var esc = this$1.readCodePoint();\r\n        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\r\n          { this$1.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\r\n        word += codePointToString(esc);\r\n        chunkStart = this$1.pos;\r\n      } else {\r\n        break\r\n      }\r\n      first = false;\r\n    }\r\n    return word + this.input.slice(chunkStart, this.pos)\r\n  };\r\n\r\n  // Read an identifier or keyword token. Will check for reserved\r\n  // words when necessary.\r\n\r\n  pp$8.readWord = function() {\r\n    var word = this.readWord1();\r\n    var type = types.name;\r\n    if (this.keywords.test(word)) {\r\n      if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word); }\r\n      type = keywords$1[word];\r\n    }\r\n    return this.finishToken(type, word)\r\n  };\r\n\r\n  // Acorn is a tiny, fast JavaScript parser written in JavaScript.\r\n  //\r\n  // Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\r\n  // various contributors and released under an MIT license.\r\n  //\r\n  // Git repositories for Acorn are available at\r\n  //\r\n  //     http://marijnhaverbeke.nl/git/acorn\r\n  //     https://github.com/acornjs/acorn.git\r\n  //\r\n  // Please use the [github bug tracker][ghbt] to report issues.\r\n  //\r\n  // [ghbt]: https://github.com/acornjs/acorn/issues\r\n  //\r\n  // This file defines the main parser interface. The library also comes\r\n  // with a [error-tolerant parser][dammit] and an\r\n  // [abstract syntax tree walker][walk], defined in other files.\r\n  //\r\n  // [dammit]: acorn_loose.js\r\n  // [walk]: util/walk.js\r\n\r\n  var version = \"5.7.2\";\r\n\r\n  // The main exported interface (under `self.acorn` when in the\r\n  // browser) is a `parse` function that takes a code string and\r\n  // returns an abstract syntax tree as specified by [Mozilla parser\r\n  // API][api].\r\n  //\r\n  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\r\n\r\n  function parse(input, options) {\r\n    return new Parser(options, input).parse()\r\n  }\r\n\r\n  // This function tries to parse a single expression at a given\r\n  // offset in a string. Useful for parsing mixed-language formats\r\n  // that embed JavaScript expressions.\r\n\r\n  function parseExpressionAt(input, pos, options) {\r\n    var p = new Parser(options, input, pos);\r\n    p.nextToken();\r\n    return p.parseExpression()\r\n  }\r\n\r\n  // Acorn is organized as a tokenizer and a recursive-descent parser.\r\n  // The `tokenizer` export provides an interface to the tokenizer.\r\n\r\n  function tokenizer(input, options) {\r\n    return new Parser(options, input)\r\n  }\r\n\r\n  // This is a terrible kludge to support the existing, pre-ES6\r\n  // interface where the loose parser module retroactively adds exports\r\n  // to this module.\r\n   // eslint-disable-line camelcase\r\n  function addLooseExports(parse, Parser$$1, plugins$$1) {\r\n    exports.parse_dammit = parse; // eslint-disable-line camelcase\r\n    exports.LooseParser = Parser$$1;\r\n    exports.pluginsLoose = plugins$$1;\r\n  }\r\n\r\n  exports.version = version;\r\n  exports.parse = parse;\r\n  exports.parseExpressionAt = parseExpressionAt;\r\n  exports.tokenizer = tokenizer;\r\n  exports.addLooseExports = addLooseExports;\r\n  exports.Parser = Parser;\r\n  exports.plugins = plugins;\r\n  exports.defaultOptions = defaultOptions;\r\n  exports.Position = Position;\r\n  exports.SourceLocation = SourceLocation;\r\n  exports.getLineInfo = getLineInfo;\r\n  exports.Node = Node;\r\n  exports.TokenType = TokenType;\r\n  exports.tokTypes = types;\r\n  exports.keywordTypes = keywords$1;\r\n  exports.TokContext = TokContext;\r\n  exports.tokContexts = types$1;\r\n  exports.isIdentifierChar = isIdentifierChar;\r\n  exports.isIdentifierStart = isIdentifierStart;\r\n  exports.Token = Token;\r\n  exports.isNewLine = isNewLine;\r\n  exports.lineBreak = lineBreak;\r\n  exports.lineBreakG = lineBreakG;\r\n  exports.nonASCIIwhitespace = nonASCIIwhitespace;\r\n\r\n  Object.defineProperty(exports, '__esModule', { value: true });\r\n\r\n  return exports;\r\n});\r\n"]}